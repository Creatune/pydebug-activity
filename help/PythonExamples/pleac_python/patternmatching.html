<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Pattern Matching</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Python
"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Hashes"
HREF="hashes.html"><LINK
REL="NEXT"
TITLE="File Access"
HREF="fileaccess.html"><style type="text/css">    <!--
      .comment {
        /* font-lock-comment-face */
        color: #bebebe;
      }
      .comment-delimiter {
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #b2dfee;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #ffa500;
      }
      .py-builtins {
        /* py-builtins-face */
        color: #ffa500;
      }
      .py-pseudo-keyword {
        /* py-pseudo-keyword-face */
        color: #ffa500;
      }
      .string {
        /* font-lock-string-face */
        color: #00cd00;
      }
      .type {
        /* font-lock-type-face */
        color: #98fb98;
      }
    -->
    </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Python
</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="hashes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="fileaccess.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PATTERNMATCHING"
>6. Pattern Matching</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN285"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">Note: regexes are used less often in Python than in Perl as tasks are often
</span><span class="comment-delimiter"># </span><span class="comment">covered by string methods, or specialised objects, modules, or packages.
</span>
<span class="keyword">import</span> re                   <span class="comment-delimiter"># </span><span class="comment">"re" is the regular expression module.
</span>re.search(<span class="string">"sheep"</span>,meadow)   <span class="comment-delimiter"># </span><span class="comment">returns a MatchObject is meadow contains "sheep".
</span><span class="keyword">if</span> <span class="keyword">not</span> re.search(<span class="string">"sheep"</span>,meadow):
    <span class="keyword">print</span> <span class="string">"no sheep on this meadow only a fat python."</span>
<span class="comment-delimiter"># </span><span class="comment">replacing strings is not done by "re"gular expressions.
</span>meadow = meadow.replace(<span class="string">"old"</span>,<span class="string">"new"</span>)   <span class="comment-delimiter"># </span><span class="comment">replace "old" with "new" and assign result.
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>re.search(<span class="string">"ovine"</span>,meadow)

meadow = <span class="string">"""Fine bovines demand fine toreadors.
Muskoxen are polar ovibovine species.
Grooviness went out of fashion decades ago."""</span>

meadow = <span class="string">"Ovines are found typically in ovaries."</span>

<span class="keyword">if</span> re.search(r<span class="string">"\bovines\b"</span>,meadow,re.I) : <span class="keyword">print</span> <span class="string">"Here be sheep!"</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">The tricky bit
</span>mystr = <span class="string">"good food"</span>
re.sub(<span class="string">"o*"</span>,<span class="string">"e"</span>,mystr,1) <span class="comment-delimiter"># </span><span class="comment">gives 'egood food'
</span>
echo ababacaca | python -c <span class="string">"import sys,re; print re.search('(a|ba|b)+(a|ac)+',sys.stdin.read()).group()"</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">pattern matching modifiers
</span><span class="comment-delimiter"># </span><span class="comment">assume perl code iterates over some file
</span><span class="keyword">import</span> re, fileinput
<span class="keyword">for</span> ln = fileinput.input():
    fnd = re.findall(<span class="string">"(\d+)"</span>,ln)
    <span class="keyword">if</span> <span class="py-builtins">len</span>(fnd) &gt; 0:
        <span class="keyword">print</span> <span class="string">"Found number %s"</span> % (fnd[0])
<span class="comment-delimiter"># </span><span class="comment">----------------------------
</span>digits = <span class="string">"123456789"</span>
nonlap = re.findall(<span class="string">"(\d\d\d)"</span>, digits)
yeslap = [<span class="string">"not yet"</span>]
<span class="keyword">print</span> <span class="string">"Non-overlapping:"</span>,<span class="string">","</span>.join(nonlap)
<span class="keyword">print</span> <span class="string">"Overlapping    :"</span>,<span class="string">","</span>.join(yeslap)
<span class="comment-delimiter"># </span><span class="comment">----------------------------
</span>mystr = <span class="string">"And little lambs eat ivy"</span>
fnd = re.search(<span class="string">"(l[^s]*s)"</span>, mystr)
<span class="keyword">print</span> <span class="string">"(%s) (%s) (%s)"</span> % (mystr[:fnd.start()], fnd.group(), mystr[fnd.end():])
<span class="comment-delimiter"># </span><span class="comment">(And ) (little lambs) ( eat ivy)
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN288"
>Copying and Substituting Simultaneously</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">import</span> re
dst = re.sub(<span class="string">"this"</span>,<span class="string">"that"</span>,src)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">strip to basename
</span>basename = re.sub(<span class="string">".*/(?=[^/]+)"</span>,<span class="string">""</span>,progname)

<span class="comment-delimiter"># </span><span class="comment">Make All Words Title-Cased
</span><span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS - use str.title() instead
</span><span class="keyword">def</span> <span class="function-name">cap</span>(mo): <span class="keyword">return</span> mo.group().capitalize()
re.sub(<span class="string">"(?P&lt;n&gt;\w+)"</span>,cap,<span class="string">"make all words title-cased"</span>)

<span class="comment-delimiter"># </span><span class="comment">/usr/man/man3/foo.1 changes to /usr/man/cat3/foo.1
</span>manpage = <span class="string">"/usr/man/man3/foo.1"</span>
catpage  = re.sub(<span class="string">"man(?=\d)"</span>,<span class="string">"cat"</span>,manpage)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>bindirs = <span class="string">"/usr/bin /bin /usr/local/bin"</span>.split()
libdirs = [d.replace(<span class="string">"bin"</span>, <span class="string">"lib"</span>) <span class="keyword">for</span> d <span class="keyword">in</span> bindirs]

<span class="keyword">print</span> <span class="string">" "</span>.join(libdirs)
<span class="comment-delimiter">#</span><span class="comment">=&gt; /usr/lib /lib /usr/local/lib
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">strings are never modified in place.
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN291"
>Matching Letters</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">#---------------------------
</span>
<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS.  use line[:-1].isalpha() [this probably goes for the
</span><span class="comment-delimiter">#    </span><span class="comment">remainder of this section too!]
</span><span class="keyword">import</span> re
<span class="keyword">if</span> re.match(<span class="string">"^[A-Za-z]+$"</span>,line):
    <span class="keyword">print</span> <span class="string">"pure alphabetic"</span>
<span class="comment-delimiter">#</span><span class="comment">#---------------------------
</span><span class="keyword">if</span> re.match(r<span class="string">"^[^\W\d_]+$"</span>, line, re.LOCALE):
    <span class="keyword">print</span> <span class="string">"pure alphabetic"</span>
<span class="comment-delimiter">#</span><span class="comment">#---------------------------
</span><span class="keyword">import</span> re
<span class="keyword">import</span> locale

<span class="keyword">try:</span>
    locale.setlocale(locale.LC_ALL, <span class="string">'fr_CA.ISO8859-1'</span>)
<span class="keyword">except:</span>
    <span class="keyword">print</span> <span class="string">"couldn't set locale to French Cnadian"</span>
    <span class="keyword">raise</span> <span class="py-builtins">SystemExit</span>

DATA=<span class="string">"""
silly
fa&#231;ade
co&#246;perate
ni&#241;o
Ren&#233;e
Moli&#232;re 
h&#230;moglobin
na&#239;ve
tsch&#252;&#223;
random!stuff#here
"""</span>

<span class="keyword">for</span> ln <span class="keyword">in</span> DATA.split():
    ln = ln.rstrip()
    <span class="keyword">if</span> re.match(r<span class="string">"^[^\W\d_]+$"</span>,ln,re.LOCALE):
        <span class="keyword">print</span> <span class="string">"%s: alphabetic"</span> % (ln)
    <span class="keyword">else:</span>
        <span class="keyword">print</span> <span class="string">"%s: line noise"</span> % (ln)
<span class="comment-delimiter"># </span><span class="comment">although i dont think "co&#246;perate" should be in canadian
</span><span class="comment-delimiter">#</span><span class="comment">#---------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN294"
>Matching Words</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">Matching Words
</span><span class="string">"\S+"</span>          <span class="comment-delimiter"># </span><span class="comment">as many non-whitespace bytes as possible
</span><span class="string">"[A-Za-z'-]+"</span>  <span class="comment-delimiter"># </span><span class="comment">as many letters, apostrophes, and hyphens
</span>
<span class="comment-delimiter"># </span><span class="comment">string split is similar to splitting on "\s+"
</span><span class="string">"A text   with some\tseparator"</span>.split()

<span class="string">"\b*([A-Za-z]+)\b*"</span>   <span class="comment-delimiter"># </span><span class="comment">word boundaries 
</span><span class="string">"\s*([A-Za-z]+)\s*"</span>   <span class="comment-delimiter"># </span><span class="comment">might work too as on letters are allowed.
</span>
re.search(<span class="string">"\Bis\B"</span>,<span class="string">"this thistle"</span>) <span class="comment-delimiter"># </span><span class="comment">matches on thistle not on this
</span>re.search(<span class="string">"\Bis\B"</span>,<span class="string">"vis-a-vis"</span>)    <span class="comment-delimiter"># </span><span class="comment">does not match
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN297"
>Commenting Regular Expressions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">resname - change all "foo.bar.com" style names in the input stream
</span><span class="comment-delimiter"># </span><span class="comment">into "foo.bar.com [204.148.40.9]" (or whatever) instead
</span>
<span class="keyword">import</span> socket               <span class="comment-delimiter"># </span><span class="comment">load inet_addr
</span><span class="keyword">import</span> fileinput
<span class="keyword">import</span> re

match = re.compile(<span class="string">"""(?P&lt;hostname&gt;  # capture hostname
                         (?:         # these parens for grouping only
                            [\w-]+   # hostname component
                            \.       # ant the domain dot
                         ) +         # now repeat that whole thing a bunch of times
                         [A-Za-z]    # next must be a letter
                         [\w-] +     # now trailing domain part
                      )              # end of hostname capture
                   """</span>,re.VERBOSE)   <span class="comment-delimiter"># </span><span class="comment">for nice formatting
</span>
<span class="keyword">def</span> <span class="function-name">repl</span>(match_obj):
    orig_hostname = match_obj.group(<span class="string">"hostname"</span>)
    <span class="keyword">try:</span>
        addr = socket.gethostbyname(orig_hostname)
    <span class="keyword">except</span> socket.gaierror:
        addr = <span class="string">"???"</span>
    <span class="keyword">return</span> <span class="string">"%s [%s]"</span> % (orig_hostname, addr)

<span class="keyword">for</span> ln <span class="keyword">in</span> fileinput.input():
    <span class="keyword">print</span> match.sub(repl, ln)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>re.sub(<span class="string">"""(?x)     # nicer formatting
          \#       #   a pound sign
          (\w+)    #   the variable name
          \#       #   another pound sign
          """</span>,
          <span class="keyword">lambda</span> m: <span class="py-builtins">eval</span>(m.group(1)),  <span class="comment-delimiter"># </span><span class="comment">replace with the value of the global variable
</span>          line
      )
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>re.sub(<span class="string">"""(?x)     # nicer formatting
          \#       #   a pound sign
          (\w+)    #   the variable name
          \#       #   another pound sign
          """</span>,
          <span class="keyword">lambda</span> m: <span class="py-builtins">eval</span>(eval(m.group(1))),  <span class="comment-delimiter"># </span><span class="comment">replace with the value of *any* variable
</span>          line
      )
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN300"
>Finding the Nth Occurrence of a Match</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">import</span> re
pond = <span class="string">"one fish two fish red fish blue fish"</span>
fishes = re.findall(r<span class="string">"(?i)(\w+)\s+fish\b"</span>,pond)
<span class="keyword">if</span> <span class="py-builtins">len</span>(fishes)&gt;2:
    <span class="keyword">print</span> <span class="string">"The third fish is a %s one."</span> % (fishes[2])
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>re.findall(r<span class="string">"(?i)(?:\w+\s+fish\s+){2}(\w+)\s+fish"</span>,pond)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>count = 0
<span class="keyword">for</span> match_object <span class="keyword">in</span> re.finditer(r<span class="string">"PAT"</span>, mystr):
    count += 1   <span class="comment-delimiter"># </span><span class="comment">or whatever you want to do here
</span>
<span class="comment-delimiter"># </span><span class="comment">"progressive" matching might be better if one wants match 5 from 50.
</span><span class="comment-delimiter"># </span><span class="comment">to count use
</span>count = <span class="py-builtins">len</span>(re.findall(r<span class="string">"PAT"</span>,mystr))
count = <span class="py-builtins">len</span>(re.findall(r<span class="string">"aba"</span>,<span class="string">"abaababa"</span>))

<span class="comment-delimiter"># </span><span class="comment">"count" overlapping matches
</span>count = <span class="py-builtins">len</span>(re.findall(r<span class="string">"(?=aba)"</span>,<span class="string">"abaababa"</span>))

<span class="comment-delimiter"># </span><span class="comment">FASTEST non-overlapping might be str.count
</span><span class="string">"abaababa"</span>.count(<span class="string">"aba"</span>)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>pond = <span class="string">"one fish two fish red fish blue fish"</span>
colors = re.findall(r<span class="string">"(?i)(\w+)\s+fish\b"</span>,pond)   <span class="comment-delimiter"># </span><span class="comment">get all matches
</span>color = colors[2]                                 <span class="comment-delimiter"># </span><span class="comment">then the one we want
</span>
<span class="comment-delimiter"># </span><span class="comment">or without a temporary list
</span>color = re.findall(r<span class="string">"(?i)(\w+)\s+fish\b"</span>,pond)[2] <span class="comment-delimiter"># </span><span class="comment">just grab element 3
</span>
<span class="keyword">print</span> <span class="string">"The third fish in the pond is %s."</span> % (color)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">import</span> re

pond = <span class="string">"one fish two fish red fish blue fish"</span>
matches = re.findall(r<span class="string">"(\w+)\s+fish\b"</span>,pond)
evens = [fish <span class="keyword">for</span> (i, fish) <span class="keyword">in</span> <span class="py-builtins">enumerate</span>(matches) <span class="keyword">if</span> i%2]
<span class="keyword">print</span> <span class="string">"Even numbered fish are %s."</span> % (<span class="string">" "</span>.join(evens))
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>count = 0
<span class="keyword">def</span> <span class="function-name">four_is_sushi</span>(match_obj):
    <span class="keyword">global</span> count
    count += 1
    <span class="keyword">if</span> count==4:
        <span class="keyword">return</span> <span class="string">"sushi%s"</span> % (match_obj.group(2))
    <span class="keyword">return</span> <span class="string">""</span>.join(match_obj.groups())

re.sub(r<span class="string">"""(?x)               # VERBOSE
           \b                 # makes next \w more efficient
           ( \w+ )            # this is what we'll be changing
           (
             \s+ fish \b
           )"""</span>,
           four_is_sushi,
           pond)
<span class="comment-delimiter"># </span><span class="comment">one fish two fish red fish sushi fish
</span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">greedily
</span>last_fish = re.findall(r<span class="string">"(?i).*\b(\w+)\s+fish\b"</span>,pond)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>pond = <span class="string">"One fish two fish red fish blue fish swim here"</span>
color = re.findall(r<span class="string">"(?i)\b(\w+)\s+fish\b"</span>,pond)[-1]
<span class="keyword">print</span> <span class="string">"Last fish is "</span>+color+<span class="string">"."</span>
<span class="comment-delimiter"># </span><span class="comment">FASTER using string.
</span>lastfish = pond.rfind(<span class="string">"fish"</span>)
color = pond[:lastfish].split()[-1]
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>r<span class="string">"""(?x)
    A             # find some pattern A
    (?!           # mustn't be able to find
      .*          # something
      A           # and A
    )
    $             # through the end of string
 """</span>

pond = <span class="string">"One fish two fish red fish blue fish swim here"</span>
fnd = re.findall(r<span class="string">"""(?xis)                # VERBOSE, CASEINSENSITIVE, DOTALL
                  \b ( \w+ ) \s+ fish \b
                  (?! .* \b fish \b )"""</span>,
                  pond)
<span class="keyword">if</span> <span class="py-builtins">len</span>(fnd):
    <span class="keyword">print</span> <span class="string">"Last fish is %s."</span> % (fnd[0])
<span class="keyword">else:</span>
    <span class="keyword">print</span> <span class="string">"Failed!"</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN303"
>Matching Multiple Lines</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">Matching Multiple Lines
</span><span class="comment-delimiter">#</span><span class="comment">
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">killtags - very bad html tag killer
</span><span class="keyword">import</span> re
<span class="keyword">import</span> sys

text = <span class="py-builtins">open</span>(sys.argv[1]).read()        <span class="comment-delimiter"># </span><span class="comment">read the whole file
</span>text = re.sub(<span class="string">"(?ms)&lt;.*?&gt;"</span>,<span class="string">""</span>,text)    <span class="comment-delimiter"># </span><span class="comment">strip tags (terrible
</span><span class="keyword">print</span> text
<span class="comment-delimiter">#</span><span class="comment"># ----------------------------
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">headerfy: change certain chapter headers to html
</span><span class="keyword">import</span> sys, re

match = re.compile(r<span class="string">"""(?xms)          # re.VERBOSE, re.MULTILINE, and re.DOTALL
                       \A              # start of the string
                       (?P&lt;chapter&gt;    # capture in g&lt;chapter&gt;
                         Chapter       # literal string
                         \s+           # mandatory whitespace
                         \d+           # decimal number
                         \s*           # optional whitespace
                         :             # a real colon
                         . *           # anything not a newline till end of line
                       )
                    """</span>)
text = <span class="py-builtins">open</span>(sys.argv[1]).read()        <span class="comment-delimiter"># </span><span class="comment">read the whole file
</span><span class="keyword">for</span> paragraph <span class="keyword">in</span> text.split(<span class="string">"\n"</span>):   <span class="comment-delimiter"># </span><span class="comment">split on unix end of lines
</span>    p = match.sub(<span class="string">"&lt;h1&gt;\g&lt;chapter&gt;&lt;/h1&gt;"</span>,paragraph)
    <span class="keyword">print</span> p
<span class="comment-delimiter">#</span><span class="comment"># ----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">the one liner does not run.
</span><span class="comment-delimiter"># </span><span class="comment">python -c 'import sys,re; for p in open(sys.argv[1]).read().split("\n\n"): print re.sub(r"(?ms)\A(Chapter\s+\d+\s*:.*)","&lt;h1&gt;\g0&lt;/h1&gt;",p)'
</span><span class="comment-delimiter">#</span><span class="comment"># ----------------------------
</span>match = re.compile(r<span class="string">"(?ms)^START(.*?)^END"</span>)
     <span class="comment-delimiter"># </span><span class="comment">s makes . span line boundaries
</span>     <span class="comment-delimiter"># </span><span class="comment">m makes ^ match at the beginning of the string and at the beginning of each line
</span>
chunk = 0
<span class="keyword">for</span> paragraph <span class="keyword">in</span> <span class="py-builtins">open</span>(sys.argv[1]).read().split(<span class="string">"\n\n"</span>):
    chunk += 1
    fnd = match.findall(paragraph)
    <span class="keyword">if</span> fnd:
        <span class="keyword">print</span> <span class="string">"chunk %d in %s has &lt;&lt;%s&gt;&gt;"</span> % (chunk,sys.argv[1],<span class="string">"&gt;&gt;,&lt;&lt;"</span>.join(fnd))
<span class="comment-delimiter">#</span><span class="comment"># ----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN306"
>Reading Records with a Pattern Separator</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">import</span> sys
<span class="comment-delimiter"># </span><span class="comment">Read the whole file and split
</span>chunks = <span class="py-builtins">open</span>(sys.argv[1]).read().split()      <span class="comment-delimiter"># </span><span class="comment">on whitespace
</span>chunks = <span class="py-builtins">open</span>(sys.argv[1]).read().split(<span class="string">"\n"</span>)  <span class="comment-delimiter"># </span><span class="comment">on line ends
</span>
<span class="comment-delimiter"># </span><span class="comment">splitting on pattern
</span><span class="keyword">import</span> re
pattern = r<span class="string">"x"</span>
chunks = re.split(pattern, <span class="py-builtins">open</span>(sys.argv[1]).read())
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>chunks = re.split(r<span class="string">"(?m)^\.(Ch|Se|Ss)$"</span>,<span class="py-builtins">open</span>(sys.argv[1]).read())
<span class="keyword">print</span> <span class="string">"I read %d chunks."</span> % (<span class="py-builtins">len</span>(chunks))
<span class="comment-delimiter"># </span><span class="comment">without delimiters
</span>chunks = re.split(r<span class="string">"(?m)^\.(?:Ch|Se|Ss)$"</span>,<span class="py-builtins">open</span>(sys.argv[1]).read())

<span class="comment-delimiter"># </span><span class="comment">with delimiters
</span>chunks = re.split(r<span class="string">"(?m)^(\.(?:Ch|Se|Ss))$"</span>,<span class="py-builtins">open</span>(sys.argv[1]).read())

<span class="comment-delimiter"># </span><span class="comment">with delimiters at chunkstart
</span>chunks = re.findall(r<span class="string">"""(?xms)       # multiline, dot matches lineend, allow comments
                          ((?:^\.)?  # consume the separator if present
                           .*?)      # match everything but not greedy
                          (?=        # end the match on this but dont consume it
                            (?:                  # dont put into group [1]
                               ^\.(?:Ch|Se|Ss)$  # either end on one of the roff commands
                               |\Z               # or end of text
                            )
                          )"""</span>,
                    <span class="py-builtins">open</span>(sys.argv[1]).read())
<span class="comment-delimiter"># </span><span class="comment">[1] if "?:" is removed the result holds tuples: ('.Ch\nchapter x','.Ch')
</span><span class="comment-delimiter">#     </span><span class="comment">which might be more usefull. 
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN309"
>Extracting a Range of Lines</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">Python doesn't have perl's range operators
</span><span class="comment-delimiter"># </span><span class="comment">If you want to only use a selected line range, use enumerate
</span><span class="comment-delimiter"># </span><span class="comment">(though note that indexing starts at zero:
</span><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="py-builtins">enumerate</span>(myfile):
    <span class="keyword">if</span> firstlinenum &lt;= i &lt; lastlinenum:
        dosomethingwith(line)

<span class="comment-delimiter"># </span><span class="comment">Using patterned ranges is slightly trickier -
</span><span class="comment-delimiter"># </span><span class="comment">You need to search for the first pattern then
</span><span class="comment-delimiter"># </span><span class="comment">search for the next pattern:
</span><span class="keyword">import</span> re
<span class="keyword">for</span> line <span class="keyword">in</span> myfile:
    <span class="keyword">if</span> re.match(pat1, line):
        <span class="keyword">break</span>

dosomethingwith(line)    <span class="comment-delimiter"># </span><span class="comment">Only if pat1 can be on same line as pat2
</span>
<span class="keyword">for</span> line <span class="keyword">in</span> myfile:
    <span class="keyword">if</span> re.match(pat2, line):
        <span class="keyword">break</span>
    dosomethingwith(line)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">If you need to extract ranges a lot, the following generator funcs
</span><span class="comment-delimiter"># </span><span class="comment">may be useful:
</span><span class="keyword">def</span> <span class="function-name">extract_range</span>(myfile, start, finish):
    <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="py-builtins">enumerate</span>(myfile):
        <span class="keyword">if</span> start &lt;= i &lt; finish:
            <span class="keyword">yield</span> line
        <span class="keyword">elif</span> i == finish:
            <span class="keyword">break</span>

<span class="keyword">for</span> line <span class="keyword">in</span> extract_range(<span class="py-builtins">open</span>(<span class="string">"/etc/passwd"</span>), 3, 5):
    <span class="keyword">print</span> line

<span class="keyword">def</span> <span class="function-name">patterned_range</span>(myfile, startpat, endpat=<span class="py-pseudo-keyword">None</span>):
    startpat = re.compile(startpat)
    <span class="keyword">if</span> endpat <span class="keyword">is</span> <span class="keyword">not</span> <span class="py-pseudo-keyword">None</span>:
        endpat = re.compile(endpat)
    in_range = <span class="py-pseudo-keyword">False</span>
    <span class="keyword">for</span> line <span class="keyword">in</span> myfile:
        <span class="keyword">if</span> re.match(startpat, line):
            in_range = <span class="py-pseudo-keyword">True</span>
        <span class="keyword">if</span> in_range:
            <span class="keyword">yield</span> line
        <span class="keyword">if</span> endpat <span class="keyword">is</span> <span class="keyword">not</span> <span class="py-pseudo-keyword">None</span> <span class="keyword">and</span> re.match(endpat, line):
            <span class="keyword">break</span>

<span class="comment-delimiter"># </span><span class="comment">DO NOT DO THIS.  Use the email module instead
</span><span class="keyword">for</span> line <span class="keyword">in</span> patterned_range(msg, <span class="string">"^From:?"</span>, <span class="string">"^$"</span>):
    <span class="keyword">pass</span> <span class="comment-delimiter">#</span><span class="comment">...
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN312"
>Matching Shell Globs as Regular Expressions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span>tests = ((<span class="string">"list.?"</span>,r<span class="string">"^list\..$"</span>),
        (<span class="string">"project.*"</span>,r<span class="string">"^project\..*$"</span>),
        (<span class="string">"*old"</span>,r<span class="string">"^.*old$"</span>),
        (<span class="string">"type*.[ch]"</span>,r<span class="string">"^type.*\.[ch]$"</span>),
        (<span class="string">"*.*"</span>,r<span class="string">"^.*\..*$"</span>),
        (<span class="string">"*"</span>,r<span class="string">"^.*$"</span>),
        )

<span class="comment-delimiter"># </span><span class="comment">The book says convert "*","?","[","]" all other characters will be quoted.
</span><span class="comment-delimiter"># </span><span class="comment">The book uses "\Q" which escapes any characters that would otherwise be
</span><span class="comment-delimiter"># </span><span class="comment">treated as regular expression.
</span><span class="comment-delimiter"># </span><span class="comment">Escaping every char fails as "\s" is not "s" in a regex.
</span>
<span class="keyword">def</span> <span class="function-name">glob2pat</span>(globstr):
    pat = globstr.replace(<span class="string">"\\"</span>,r<span class="string">"\\"</span>)
    pat = pat.replace(<span class="string">"."</span>,r<span class="string">"\."</span>).replace(<span class="string">"?"</span>,r<span class="string">"."</span>).replace(<span class="string">"*"</span>,r<span class="string">".*"</span>)
    
    <span class="keyword">return</span> <span class="string">"^"</span>+pat+<span class="string">"$"</span>

<span class="keyword">for</span> globstr, patstr <span class="keyword">in</span> tests:
    g2p = glob2pat(globstr)
    <span class="keyword">if</span> g2p != patstr:
        <span class="keyword">print</span> globstr, <span class="string">"failed! Should be"</span>, patstr, <span class="string">"but was"</span>, g2p</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN315"
>Speeding Up Interpolated Matches</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span>
<span class="comment-delimiter"># </span><span class="comment"><font size="-1"><a href="http://pleac.sourceforge.net/include/python/ch06/popgrep1">download the following standalone program</a></font>
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">popgrep1 - grep for abbreviations of places that say "pop"
</span><span class="comment-delimiter"># </span><span class="comment">version 1: slow but obvious way
</span><span class="keyword">import</span> fileinput
<span class="keyword">import</span> re
popstates = [<span class="string">"CO"</span>,<span class="string">"ON"</span>,<span class="string">"MI"</span>,<span class="string">"WI"</span>,<span class="string">"MN"</span>]
<span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():
    <span class="keyword">for</span> state <span class="keyword">in</span> popstates:
        <span class="keyword">if</span> re.search(r<span class="string">"\b"</span>+state+r<span class="string">"\b"</span>,line):
            <span class="keyword">print</span> line



<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment"><font size="-1"><a href="http://pleac.sourceforge.net/include/python/ch06/popgrep2">download the following standalone program</a></font>
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">popgrep2 - grep for abbreviations of places that say "pop"
</span><span class="comment-delimiter"># </span><span class="comment">version 2: compile the patterns
</span><span class="keyword">import</span> fileinput
<span class="keyword">import</span> re
popstates = [<span class="string">"CO"</span>,<span class="string">"ON"</span>,<span class="string">"MI"</span>,<span class="string">"WI"</span>,<span class="string">"MN"</span>]
state_re = []
<span class="keyword">for</span> state <span class="keyword">in</span> popstates:
    state_re.append(re.compile(r<span class="string">"\b"</span>+state+r<span class="string">"\b"</span>))
<span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():
    <span class="keyword">for</span> state <span class="keyword">in</span> state_re:
        <span class="keyword">if</span> state.search(line):
            <span class="keyword">print</span> line


<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment"><font size="-1"><a href="http://pleac.sourceforge.net/include/python/ch06/popgrep3">download the following standalone program</a></font>
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">popgrep3 - grep for abbreviations of places that say "pop"
</span><span class="comment-delimiter"># </span><span class="comment">version 3: compile a single pattern
</span><span class="keyword">import</span> fileinput
<span class="keyword">import</span> re
popstates = [<span class="string">"CO"</span>,<span class="string">"ON"</span>,<span class="string">"MI"</span>,<span class="string">"WI"</span>,<span class="string">"MN"</span>]
state_re = re.compile(r<span class="string">"\b(?:"</span>+<span class="string">"|"</span>.join(popstates)+r<span class="string">")\b"</span>)
<span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():
    <span class="keyword">if</span> state_re.search(line):
        <span class="keyword">print</span> line


<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment"><font size="-1"><a href="http://pleac.sourceforge.net/include/python/ch06/grepauth">download the following standalone program</a></font>
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">grepauth - print lines that mention both Tom and Nat
</span><span class="keyword">import</span> fileinput
<span class="keyword">import</span> re

<span class="keyword">def</span> <span class="function-name">build_match_any</span>(words):
    <span class="keyword">return</span> re.compile(<span class="string">"|"</span>.join(words))
<span class="keyword">def</span> <span class="function-name">uniq</span>(arr):
    seen = {}
    <span class="keyword">for</span> item <span class="keyword">in</span> arr:
        seen[item] = seen.get(item, 0) + 1
    <span class="keyword">return</span> seen.keys()
<span class="keyword">def</span> <span class="function-name">build_match_all</span>(words):
    r = re.compile(<span class="string">"|"</span>.join(words))
    c = <span class="keyword">lambda</span> line: <span class="py-builtins">len</span>(uniq(r.findall(line)))&gt;=<span class="py-builtins">len</span>(words)
    <span class="keyword">return</span> c

any = build_match_any((<span class="string">"Tom"</span>,<span class="string">"Nat"</span>))
all = build_match_all((<span class="string">"Tom"</span>,<span class="string">"Nat"</span>))
<span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():
    <span class="keyword">if</span> any.search(line):
        <span class="keyword">print</span> <span class="string">"any:"</span>, line
    <span class="keyword">if</span> all(line):
        <span class="keyword">print</span> <span class="string">"all:"</span>, line



<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN318"
>Testing for a Valid Pattern</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">Testing for a Valid Pattern
</span>
<span class="keyword">import</span> re
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    pat = <span class="py-builtins">raw_input</span>(<span class="string">"Pattern? "</span>)
    <span class="keyword">try:</span>
        re.compile(pat)
    <span class="keyword">except</span> re.error, err:
        <span class="keyword">print</span> <span class="string">"INVALID PATTERN"</span>, err
        <span class="keyword">continue</span>
    <span class="keyword">break</span>

<span class="comment-delimiter"># </span><span class="comment">----
</span><span class="keyword">def</span> <span class="function-name">is_valid_pattern</span>(pat):
    <span class="keyword">try:</span>
        re.compile(pat)
    <span class="keyword">except</span> re.error:
        <span class="keyword">return</span> <span class="py-pseudo-keyword">False</span>
    <span class="keyword">return</span> <span class="py-pseudo-keyword">True</span>

<span class="comment-delimiter"># </span><span class="comment">----
</span>
<span class="comment-delimiter"># </span><span class="comment"><font size="-1"><a href="http://pleac.sourceforge.net/include/python/ch06/paragrep">download the following standalone program</a></font>
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">paragrep - trivial paragraph grepper
</span><span class="comment-delimiter">#</span><span class="comment">
</span><span class="comment-delimiter"># </span><span class="comment">differs from perl version in parano.
</span><span class="comment-delimiter"># </span><span class="comment">python version displays paragraph in current file.
</span>
<span class="keyword">import</span> sys, os.path, re
<span class="keyword">if</span> <span class="py-builtins">len</span>(sys.argv)&lt;=1:
        <span class="keyword">print</span> <span class="string">"usage: %s pat [files]\n"</span> % sys.argv[0]
        sys.exit(1)

pat = sys.argv[1]
<span class="keyword">try:</span>
        pat_re = re.compile(pat)
<span class="keyword">except:</span>
        <span class="keyword">print</span> <span class="string">"%s: bad pattern %s: %s"</span> % (sys.argv[1], pat, sys.exc_info()[1])
        sys.exit(1)
<span class="keyword">for</span> filename <span class="keyword">in</span> <span class="py-builtins">filter</span>(os.path.isfile,sys.argv[2:]):
        parano = 0
        <span class="keyword">for</span> para <span class="keyword">in</span> <span class="py-builtins">open</span>(filename).read().split(<span class="string">"\n\n"</span>):
                parano += 1
                <span class="keyword">if</span> pat_re.search(para):
                        <span class="keyword">print</span> filename, parano, para, <span class="string">"\n"</span>
                        


<span class="comment-delimiter"># </span><span class="comment">----
</span>
<span class="comment-delimiter"># </span><span class="comment">as we dont evaluate patterns the attack ::
</span><span class="comment-delimiter">#</span><span class="comment">
</span><span class="comment-delimiter">#   </span><span class="comment">$pat = "You lose @{[ system('rm -rf *']} big here";
</span><span class="comment-delimiter">#</span><span class="comment">
</span><span class="comment-delimiter"># </span><span class="comment">does not work.
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN321"
>Honoring Locale Settings in Regular Expressions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span>
<span class="comment-delimiter"># </span><span class="comment"><font size="-1"><a href="http://pleac.sourceforge.net/include/python/ch06/localeg">download the following standalone program</a></font>
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">localeg - demonstrates locale effects
</span><span class="comment-delimiter">#</span><span class="comment">
</span><span class="comment-delimiter"># </span><span class="comment">re must be told to respect locale either in the regexp
</span><span class="comment-delimiter"># </span><span class="comment">"(?L)" or as flag to the call (python 2.4) "re.LOCALE".
</span>
<span class="keyword">import</span> sys
<span class="keyword">import</span> re, string
<span class="keyword">from</span> locale <span class="keyword">import</span> LC_CTYPE, setlocale, getlocale

name = <span class="string">"andreas k\xF6nig"</span>
locale = {<span class="string">"German"</span> : <span class="string">"de_DE.ISO_8859-1"</span>, <span class="string">"English"</span> : <span class="string">"en_US"</span>}
<span class="comment-delimiter"># </span><span class="comment">us-ascii is not supported on linux py23
</span><span class="comment-delimiter"># </span><span class="comment">none works in activestate py24
</span>
<span class="keyword">try:</span>
    setlocale(LC_CTYPE, locale[<span class="string">"English"</span>])
<span class="keyword">except:</span>
    <span class="keyword">print</span> <span class="string">"Invalid locale %s"</span> % locale[<span class="string">"English"</span>]
    sys.exit(1)
english_names = []
<span class="keyword">for</span> n <span class="keyword">in</span> re.findall(r<span class="string">"(?L)\b(\w+)\b"</span>,name):
    english_names.append(n.capitalize())

<span class="keyword">try:</span>
    setlocale(LC_CTYPE, locale[<span class="string">"German"</span>])
<span class="keyword">except:</span>
    <span class="keyword">print</span> <span class="string">"Invalid locale %s"</span> % locale[<span class="string">"German"</span>]
    sys.exit(1)
german_names = <span class="py-builtins">map</span>(string.capitalize, re.findall(r<span class="string">"(?L)\b(\w+)\b"</span>,name))

<span class="keyword">print</span> <span class="string">"English names: %s"</span> % <span class="string">" "</span>.join(english_names)
<span class="keyword">print</span> <span class="string">"German names: %s"</span> % <span class="string">" "</span>.join(german_names)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN324"
>Approximate Matching</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">import</span> difflib
matchlist = [<span class="string">"ape"</span>, <span class="string">"apple"</span>, <span class="string">"lapel"</span>, <span class="string">"peach"</span>, <span class="string">"puppy"</span>]
<span class="keyword">print</span> difflib.get_close_matches(<span class="string">"appel"</span>, matchlist)
<span class="comment-delimiter">#</span><span class="comment">=&gt; ['lapel', 'apple', 'ape']
</span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">Also see:
</span><span class="comment-delimiter">#     </span><span class="comment">http://www.personal.psu.edu/staff/i/u/iua1/python/apse/
</span><span class="comment-delimiter">#     </span><span class="comment">http://www.bio.cam.ac.uk/~mw263/pyagrep.html
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN327"
>Matching from Where the Last Pattern Left Off</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">To search (potentially) repeatedly for a pattern, use re.finditer():
</span>
<span class="comment-delimiter"># </span><span class="comment">DO NOT DO THIS.  Split on commas and convert elems using int()
</span>mystr = <span class="string">"3,4,5,9,120"</span>
<span class="keyword">for</span> match <span class="keyword">in</span> re.finditer(<span class="string">"(\d+)"</span>, mystr):
    n = match.group(0)
    <span class="keyword">if</span> n == <span class="string">"9"</span>:
        <span class="keyword">break</span> <span class="comment-delimiter"># </span><span class="comment">'120' will never be matched
</span>    <span class="keyword">print</span> <span class="string">"Found number"</span>, n

<span class="comment-delimiter"># </span><span class="comment">matches know their end position
</span>mystr = <span class="string">"The year 1752 lost 10 days on the 3rd of September"</span>
x = re.finditer(<span class="string">"(\d+)"</span>, mystr)
<span class="keyword">for</span> match <span class="keyword">in</span> x:
    n = match.group(0)
    <span class="keyword">print</span> <span class="string">"Found number"</span>, n

tail = re.match(<span class="string">"(\S+)"</span>, mystr[match.end():])
<span class="keyword">if</span> tail:
    <span class="keyword">print</span> <span class="string">"Found %s after the last number."</span>%tail.group(0)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN330"
>Greedy and Non-Greedy Matches</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">Python's regexes are based on Perl's, so it has the non-greedy 
</span><span class="comment-delimiter"># </span><span class="comment">'*?', '+?', and '??' versions of '*', '+', and '?'.
</span><span class="comment-delimiter"># </span><span class="comment">DO NOT DO THIS. import htmllib, formatter, etc, instead
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">greedy pattern
</span>txt = re.sub(<span class="string">"&lt;.*&gt;"</span>, <span class="string">""</span>, txt) <span class="comment-delimiter"># </span><span class="comment">try to remove tags, very badly
</span>
<span class="comment-delimiter"># </span><span class="comment">non-greedy pattern
</span>txt = re.sub(<span class="string">"&lt;.*?&gt;"</span>, <span class="string">""</span>, txt) <span class="comment-delimiter"># </span><span class="comment">try to remove tags, still rather badly
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>txt = <span class="string">"&lt;b&gt;&lt;i&gt;this&lt;/i&gt; and &lt;i&gt;that&lt;/i&gt; are important&lt;/b&gt; Oh, &lt;b&gt;&lt;i&gt;me too!&lt;/i&gt;&lt;/b&gt;"</span>

<span class="keyword">print</span> re.findall(<span class="string">"&lt;b&gt;&lt;i&gt;(.*?)&lt;/i&gt;&lt;/b&gt;"</span>, txt
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">print</span> re.findall(<span class="string">"/BEGIN((?:(?!BEGIN).)*)END/"</span>, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">print</span> re.findall(<span class="string">"&lt;b&gt;&lt;i&gt;((?:(?!&lt;b&gt;|&lt;i&gt;).)*)&lt;/i&gt;&lt;/b&gt;"</span>, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">print</span> re.findall(<span class="string">"&lt;b&gt;&lt;i&gt;((?:(?!&lt;[ib]&gt;).)*)&lt;/i&gt;&lt;/b&gt;"</span>, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">print</span> re.findall(<span class="string">"""
    &lt;b&gt;&lt;i&gt; 
    [^&lt;]*  # stuff not possibly bad, and not possibly the end.
    (?:    # at this point, we can have '&lt;' if not part of something bad
     (?!  &lt;/?[ib]&gt;  )   # what we can't have
     &lt;                  # okay, so match the '&lt;'
     [^&lt;]*              # and continue with more safe stuff
    ) *
    &lt;/i&gt;&lt;/b&gt;
    """</span>, re.VERBOSE, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN333"
>Detecting Duplicate Words</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>text = <span class="string">"""
This is a test
test of the duplicate word finder.
"""</span>
words = text.split()
<span class="keyword">for</span> curr, next <span class="keyword">in</span> <span class="py-builtins">zip</span>(words[:-1], words[1:]):
    <span class="keyword">if</span> curr.upper() == next.upper():
            <span class="keyword">print</span> <span class="string">"Duplicate word '%s' found."</span> % curr

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS
</span><span class="keyword">import</span> re
pat = r<span class="string">"""
      \b            # start at a word boundary (begin letters)
      (\S+)         # find chunk of non-whitespace
      \b            # until another word boundary (end letters)
      (
          \s+       # separated by some whitespace
          \1        # and that very same chunk again
          \b        # until another word boundary
      ) +           # one or more sets of those
      """</span>
<span class="keyword">for</span> match <span class="keyword">in</span> re.finditer(pat, text, flags=re.VERBOSE|re.IGNORECASE):
    <span class="keyword">print</span> <span class="string">"Duplicate word '%s' found."</span> % match.group(1)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>a = <span class="string">'nobody'</span>;
b = <span class="string">'bodysnatcher'</span>;

text = a+<span class="string">" "</span>+b
pat = r<span class="string">"^(\w+)(\w+) \2(\w+)$"</span>
<span class="keyword">for</span> match <span class="keyword">in</span> re.finditer(pat, text):
    m1, m2, m3 = match.groups()
    <span class="keyword">print</span> m2, <span class="string">"overlaps in %s-%s-%s"</span>%(m1, m2, m3)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>pat = r<span class="string">"^(\w+?)(\w+) \2(\w+)$"</span>
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">try:</span>
    <span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
        factor = re.match(r<span class="string">"^(oo+?)\1+$"</span>, n).group(1)
        n = re.sub(factor, <span class="string">"o"</span>, n)
        <span class="keyword">print</span> <span class="py-builtins">len</span>(factor)
<span class="keyword">except</span> <span class="py-builtins">AttributeError</span>:
    <span class="keyword">print</span> <span class="py-builtins">len</span>(n)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">def</span> <span class="function-name">diaphantine</span>(n, x, y, z):
    pat = r<span class="string">"^(o*)\1{%s}(o*)\2{%s}(o*)\3{%s}$"</span>%(x-1, y-1, z-1)
    text = <span class="string">"o"</span>*n
    <span class="keyword">try:</span>
        vals = [<span class="py-builtins">len</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> re.match(pat, text).groups()]
    <span class="keyword">except</span> <span class="py-builtins">ValueError</span>:
        <span class="keyword">print</span> <span class="string">"No solutions."</span>
    <span class="keyword">else:</span>
        <span class="keyword">print</span> <span class="string">"One solution is: x=%s, y=%s, z=%s."</span>%<span class="py-builtins">tuple</span>(vals)
        
diaphantine(n=281, x=12, y=15, z=16)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN336"
>Expressing AND, OR, and NOT in a Single Pattern</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">Pass any of the following patterns to re.match(), etc
</span>pat = <span class="string">"ALPHA|BETA"</span>
pat = <span class="string">"^(?=.*ALPHA)(?=.*BETA)"</span>
pat = <span class="string">"ALPHA.*BETA|BETA.*ALPHA"</span>
pat = <span class="string">"^(?:(?!PAT).)*$"</span>
pat = <span class="string">"(?=^(?:(?!BAD).)*$)GOOD"</span>
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">if</span> <span class="keyword">not</span> re.match(pattern, text):
    something()
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">if</span> re.match(pat1, text) <span class="keyword">and</span> re.match(pat2, text):
    something()
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">if</span> re.match(pat1, text) <span class="keyword">or</span> re.match(pat2, text):
    something()
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS.
</span><span class="string">"""minigrep - trivial grep"""</span>
<span class="keyword">import</span> sys, re

pat = sys.argv[1]
<span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:
    <span class="keyword">if</span> re.match(pat, line):
        <span class="keyword">print</span> line[:-1]
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">if</span> re.match(r<span class="string">"^(?=.*bell)(?=.*lab)"</span>, <span class="string">"labelled"</span>):
    something()
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">if</span> re.search(<span class="string">"bell"</span>, s) <span class="keyword">and</span> re.search(<span class="string">"lab"</span>, s):
    something()
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">if</span> re.match(<span class="string">"""
             ^              # start of string
            (?=             # zero-width lookahead
                .*          # any amount of intervening stuff
                bell        # the desired bell string
            )               # rewind, since we were only looking
            (?=             # and do the same thing
                .*          # any amount of intervening stuff
                lab         # and the lab part
            )
            """</span>,
            murray_hill,
            re.DOTALL | re.VERBOSE):
    <span class="keyword">print</span> <span class="string">"Looks like Bell Labs might be in Murray Hill!"</span>
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">if</span> re.match(r<span class="string">"(?:^.*bell.*lab)|(?:^.*lab.*bell)"</span>, <span class="string">"labelled"</span>):
    something()
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>brand = <span class="string">"labelled"</span>
<span class="keyword">if</span> re.match(<span class="string">"""
            (?:                 # non-capturing grouper
                ^ .*?           # any amount of stuff at the front
                bell            # look for a bell
                .*?             # followed by any amount of anything
                lab             # look for a lab
            )                   # end grouper
            |                   # otherwise, try the other direction
            (?:                 # non-capturing grouper
                ^ .*?           # any amount of stuff at the front
                lab             # look for a lab
                .*?             # followed by any amount of anything
                bell            # followed by a bell
            )                   # end grouper
            """</span>,
            brand,
            re.DOTALL | re.VERBOSE):
    <span class="keyword">print</span> <span class="string">"Our brand has bell and lab separate."</span>
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>x = <span class="string">"odlaw"</span>
<span class="keyword">if</span> re.match(<span class="string">"^(?:(?!waldo).)*$"</span>, x):
   <span class="keyword">print</span> <span class="string">"There's no waldo here!"</span>
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">if</span> re.match(<span class="string">"""
            ^                   # start of string
            (?:                 # non-capturing grouper
                (?!             # look ahead negation
                    waldo       # is he ahead of us now?
                )               # is so, the negation failed
                .               # any character (cuzza /s)
            ) *                 # repeat that grouping 0 or more
            $                   # through the end of the string
            """</span>,
            x,
            re.VERBOSE | re.DOTALL):
    <span class="keyword">print</span> <span class="string">"There's no waldo here!\n"</span>;
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN339"
>Matching Multiple-Byte Characters</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">@@INCOMPLETE@@
</span><span class="comment-delimiter"># </span><span class="comment">@@INCOMPLETE@@
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN342"
>Matching a Valid Mail Address</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">from</span> email._parseaddr <span class="keyword">import</span> AddressList

<span class="keyword">print</span> AddressList(<span class="string">"fred&amp;barney@stonehenge.com"</span>).addresslist[0]

<span class="keyword">print</span> AddressList(<span class="string">"fred&amp;barney@stonehenge.com (Hanna Barbara)"</span>).addresslist[0]

name, address = AddressList(<span class="string">"Mr Fooby Blah &lt;<a href="mailto:me&#64;nowhere.com">me&#64;nowhere.com</a>&gt;"</span>).addresslist[0]
<span class="keyword">print</span> <span class="string">"%s's address is '%s'"</span>%(name, address)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN345"
>Matching Abbreviations</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">Assuming the strings all start with different letters, or you don't
</span><span class="comment-delimiter"># </span><span class="comment">mind there being precedence, use the startswith string method:
</span>
<span class="keyword">def</span> <span class="function-name">get_action</span>(answer):
    answer = answer.lower()
    actions = [<span class="string">"send"</span>, <span class="string">"stop"</span>, <span class="string">"abort"</span>, <span class="string">"list"</span>, <span class="string">"end"</span>]
    <span class="keyword">for</span> action <span class="keyword">in</span> actions:
        <span class="keyword">if</span> action.startswith(answer):
            <span class="keyword">return</span> action

<span class="keyword">print</span> <span class="string">"Action is %s."</span>%get_action(<span class="string">"L"</span>)
<span class="comment-delimiter">#</span><span class="comment">=&gt; Action is list.
</span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment">DON'T DO THIS:
</span><span class="keyword">import</span> re
answer = <span class="string">"ab"</span>
answer = re.escape(answer.strip())
<span class="keyword">for</span> action <span class="keyword">in</span> (<span class="string">"SEND"</span>, <span class="string">"STOP"</span>, <span class="string">"ABORT"</span>, <span class="string">"LIST"</span>, <span class="string">"EDIT"</span>):
    <span class="keyword">if</span> re.match(answer, action, flags=re.IGNORECASE):
        <span class="keyword">print</span> <span class="string">"Action is %s."</span>%action.lower()
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">import</span> re, sys
<span class="keyword">def</span> <span class="function-name">handle_cmd</span>(cmd):    
    cmd = re.escape(cmd.strip())
    <span class="keyword">for</span> name, action <span class="keyword">in</span> {<span class="string">"edit"</span>: invoke_editor,
                         <span class="string">"send"</span>: deliver_message,
                         <span class="string">"list"</span>: lambda: system(pager, myfile),
                         <span class="string">"abort"</span>: sys.exit,
                         }
        <span class="keyword">if</span> re.match(cmd, name, flags=re.IGNORECASE):
            action()
            <span class="keyword">break</span>
    <span class="keyword">else:</span>
        <span class="keyword">print</span> <span class="string">"Unknown command:"</span>, cmd
handle_cmd(<span class="string">"ab"</span>)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN348"
>Program: urlify</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">urlify - wrap HTML links around URL-like constructs
</span><span class="keyword">import</span> re, sys, fileinput

<span class="keyword">def</span> <span class="function-name">urlify_string</span>(s):
    urls = r<span class="string">'(http|telnet|gopher|file|wais|ftp)'</span>
    
    ltrs = r<span class="string">'\w'</span>;
    gunk = r<span class="string">'/#~:.?+=&amp;%@!\-'</span>
    punc = r<span class="string">'.:?\-'</span>
    any  = ltrs + gunk + punc 

    pat = re.compile(r<span class="string">"""
      \b                    # start at word boundary
      (                     # begin \1  {
       %(urls)s  :          # need resource and a colon
       [%(any)s] +?         # followed by one or more
                            #  of any valid character, but
                            #  be conservative and take only
                            #  what you need to....
      )                     # end   \1  }
      (?=                   # look-ahead non-consumptive assertion
       [%(punc)s]*          # either 0 or more punctuation
       [^%(any)s]           #   followed by a non-url char
       |                    # or else
       $                    #   then end of the string
      )
    """</span>%<span class="py-builtins">locals</span>(), re.VERBOSE | re.IGNORECASE)
    <span class="keyword">return</span> re.sub(pat, r<span class="string">"&lt;A HREF=\1&gt;\1&lt;/A&gt;"</span>, s)

<span class="keyword">if</span> <span class="py-builtins">__name__</span> == <span class="string">"__main__"</span>:
    <span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():
        <span class="keyword">print</span> urlify_string(line)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN351"
>Program: tcgrep</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">@@INCOMPLETE@@
</span><span class="comment-delimiter"># </span><span class="comment">@@INCOMPLETE@@
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN354"
>Regular Expression Grabbag</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">The majority of regexes in this section are either partially
</span><span class="comment-delimiter"># </span><span class="comment">or completely The Wrong Thing to Do.
</span><span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS.  Use a Roman Numeral module, etc. (since
</span><span class="comment-delimiter"># </span><span class="comment">you need one anyway to calculate values)
</span>pat = r<span class="string">"^m*(d?c{0,3}|c[dm])(l?x{0,3}|x[lc])(v?i{0,3}|i[vx])$"</span>
re.match(pat, <span class="string">"mcmlxcvii"</span>)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>txt = <span class="string">"one two three four five"</span>

<span class="comment-delimiter"># </span><span class="comment">If the words are cleanly delimited just split and rejoin:
</span>word1, word2, rest = txt.split(<span class="string">" "</span>, 2)
<span class="keyword">print</span> <span class="string">" "</span>.join([word2, word1, rest])

<span class="comment-delimiter"># </span><span class="comment">Otherwise:
</span>frompat = r<span class="string">"(\S+)(\s+)(\S+)"</span>
topat =  r<span class="string">"\3\2\1"</span>
<span class="keyword">print</span> re.sub(frompat, topat, txt)

<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">print</span> str.split(<span class="string">"="</span>)

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS
</span>pat = r<span class="string">"(\w+)\s*=\s*(.*)\s*$"</span>
<span class="keyword">print</span> re.match(pat, <span class="string">"key=val"</span>).groups()
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>line = <span class="string">"such a very very very very very very very very very very very very very long line"</span>
<span class="keyword">if</span> <span class="py-builtins">len</span>(line) &gt; 80:
    process(line)

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS
</span>pat = <span class="string">".{80,}"</span>
<span class="keyword">if</span> re.match(pat, line):
    process(line)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>dt = time.strptime(<span class="string">"12/11/05 12:34:56"</span>, <span class="string">"%d/%m/%y %H:%M:%S"</span>)

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS
</span>pat = r<span class="string">"(\d+)/(\d+)/(\d+) (\d+):(\d+):(\d+)"</span>
dt = re.match(pat, <span class="string">"12/11/05 12:34:56"</span>).groups()
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>txt = <span class="string">"/usr/bin/python"</span>
<span class="keyword">print</span> txt.replace(<span class="string">"/usr/bin"</span>, <span class="string">"/usr/local/bin"</span>)
<span class="comment-delimiter"># </span><span class="comment">Alternatively for file operations use os.path, shutil, etc.
</span>
<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS
</span><span class="keyword">print</span> re.sub(<span class="string">"/usr/bin"</span>, <span class="string">"/usr/local/bin"</span>, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">import</span> re

<span class="keyword">def</span> <span class="function-name">unescape_hex</span>(matchobj):
    <span class="keyword">return</span> <span class="py-builtins">chr</span>(int(matchobj.groups(0)[0], 16))
txt = re.sub(r<span class="string">"%([0-9A-Fa-f][0-9A-Fa-f])"</span>, unescape_hex, txt)

<span class="comment-delimiter"># </span><span class="comment">Assuming that the hex escaping is well-behaved, an alternative is:
</span><span class="keyword">def</span> <span class="function-name">unescape_hex</span>(seg):
    <span class="keyword">return</span> <span class="py-builtins">chr</span>(int(seg[:2], 16)) + seg[2:]

segs = txt.split(<span class="string">"%"</span>)
txt = segs[0] + <span class="string">""</span>.join(unescape_hex(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segs[1:])
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>txt = re.sub(r<span class="string">"""
             /\*                    # Match the opening delimiter
             .*?                    # Match a minimal number of characters
             \*/                    # Match the closing delimiter
             """</span>, <span class="string">""</span>, txt, re.VERBOSE)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>txt.strip()

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS
</span>txt = re.sub(r<span class="string">"^\s+"</span>, <span class="string">""</span>, txt)
txt = re.sub(r<span class="string">"\s+$"</span>, <span class="string">""</span>, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>txt.replace(<span class="string">"\\n"</span>, <span class="string">"\n"</span>)

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS
</span>txt = re.sub(<span class="string">"\\n"</span>, <span class="string">"\n"</span>, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>txt = re.sub(<span class="string">"^.*::"</span>, <span class="string">""</span>)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">import</span> socket
socket.inet_aton(txt) <span class="comment-delimiter"># </span><span class="comment">Will raise an error if incorrect
</span>
<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS.
</span>octseg =r<span class="string">"([01]?\d\d|2[0-4]\d|25[0-5])"</span>
dot = r<span class="string">"\."</span>
pat = <span class="string">"^"</span> + octseg + dot + octseg + dot + octseg + dot + octseg + <span class="string">"$"</span>

<span class="keyword">if</span> <span class="keyword">not</span> re.match(pat, txt, re.VERBOSE)
   <span class="keyword">raise</span> <span class="py-builtins">ValueError</span>

<span class="comment-delimiter"># </span><span class="comment">Defitely DON'T DO THIS.
</span>pat = r<span class="string">"""^([01]?\d\d|2[0-4]\d|25[0-5])\.([01]?\d\d|2[0-4]\d|25[0-5])\.
          ([01]?\d\d|2[0-4]\d|25[0-5])\.([01]?\d\d|2[0-4]\d|25[0-5])$"""</span>
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>fname = os.path.basename(path)

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS.
</span>fname = re.sub(<span class="string">"^.*/"</span>, <span class="string">""</span>, path)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">import</span> os
<span class="keyword">try:</span>
    tc = os.environ[<span class="string">"TERMCAP"</span>]
<span class="keyword">except</span> <span class="py-builtins">KeyError</span>:
    cols = 80
<span class="keyword">else:</span>
    cols = re.match(<span class="string">":co#(\d+):"</span>).groups(1)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">(not quite equivalent to the Perl version)
</span>name = os.path.basename(sys.argv[0])

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS.
</span>name = re.sub(<span class="string">"^.*/"</span>, <span class="string">""</span>, sys.argv[0])
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">if</span> sys.platform != <span class="string">"linux"</span>:
    <span class="keyword">raise</span> <span class="py-builtins">SystemExit</span>(<span class="string">"This isn't Linux"</span>)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>txt = re.sub(r<span class="string">"\n\s+"</span>, <span class="string">" "</span>, txt)

<span class="comment-delimiter"># </span><span class="comment">In many cases you could just use:
</span>txt = txt.replace(<span class="string">"\n"</span>, <span class="string">" "</span>)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>nums = re.findall(r<span class="string">"\d+\.?\d*|\.\d+"</span>, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">If the words are clearly delimited just use:
</span>capwords = [word <span class="keyword">for</span> word <span class="keyword">in</span> txt.split() <span class="keyword">if</span> word.isupper()]

<span class="comment-delimiter"># </span><span class="comment">Otherwise
</span>capwords = [word <span class="keyword">for</span> word <span class="keyword">in</span> re.findall(r<span class="string">"\b(\S+)\b"</span>, txt) <span class="keyword">if</span> word.isupper()]

<span class="comment-delimiter"># </span><span class="comment">(probably) DON'T DO THIS. 
</span>capwords = re.findall(r<span class="string">"(\b[^\Wa-z0-9_]+\b)"</span>, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">If the words are clearly delimited just use:
</span>lowords = [word <span class="keyword">for</span> word <span class="keyword">in</span> txt.split() <span class="keyword">if</span> word.islower()]

<span class="comment-delimiter"># </span><span class="comment">Otherwise
</span>lowords = [word <span class="keyword">for</span> word <span class="keyword">in</span> re.findall(r<span class="string">"\b(\S+)\b"</span>, txt) <span class="keyword">if</span> word.islower()]

<span class="comment-delimiter"># </span><span class="comment">(probably) DON'T DO THIS. 
</span>lowords = re.findall(r<span class="string">"(\b[^\WA-Z0-9_]+\b)"</span>, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">If the words are clearly delimited just use:
</span>icwords = [word <span class="keyword">for</span> word <span class="keyword">in</span> txt.split() <span class="keyword">if</span> word.istitle()]

<span class="comment-delimiter"># </span><span class="comment">Otherwise
</span>icwords = [word <span class="keyword">for</span> word <span class="keyword">in</span> re.finditer(r<span class="string">"\b(\S+)\b"</span>) <span class="keyword">if</span> word.istitle()]

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS. 
</span>icwords = re.findall(r<span class="string">"(\b[^\Wa-z0-9_][^\WA-Z0-9_]*\b)"</span>, txt)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS - use HTMLParser, etc.
</span>links = re.findall(r<span class="string">"""&lt;A[^&gt;]+?HREF\s*=\s*["']?([^'" &gt;]+?)[ '"</span>]?&gt;<span class="string">""", txt)
##-----------------------------
names = txt.split()
if len(names) == 3:
    initial = names[1][0]
else:
    initial = ""

# DON'T DO THIS. 
pat = "</span>^\S+\s+(\S)\S*\s+\S<span class="string">"
try:
    initial = re.match(pat, txt).group(1)
except AttributeError:
    initial = ""
##-----------------------------
txt = re.sub('"</span>([^<span class="string">"]*)"', "``\1''", txt)
##-----------------------------
sentences = [elem[0] for elem in re.findall(r"(.*?[!?.])(  |\Z)", s)]
##-----------------------------
import time
dt = time.strptime(txt, "%Y-%m-%d")

# DON'</span>T DO THIS.
year, month, day = re.match(r<span class="string">"(\d{4})-(\d\d)-(\d\d)"</span>, txt).groups()
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>pat = r<span class="string">"""
      ^
      (?:
       1 \s (?: \d\d\d \s)?            # 1, or 1 and area code
       |                               # ... or ...
       \(\d\d\d\) \s                   # area code with parens
       |                               # ... or ...
       (?: \+\d\d?\d? \s)?             # optional +country code
       \d\d\d ([\s\-])                 # and area code
      )
      \d\d\d (\s|\1)                   # prefix (and area code separator)
      \d\d\d\d                         # exchange
        $
      """</span>
re.match(pat, txt, re.VERBOSE)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span>re.match(r<span class="string">"\boh\s+my\s+gh?o(d(dess(es)?|s?)|odness|sh)\b"</span>, txt, re.IGNORECASE)
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span><span class="keyword">for</span> line <span class="keyword">in</span> <span class="py-builtins">file</span>(fname, <span class="string">"Ur"</span>):          <span class="comment-delimiter">#</span><span class="comment">Universal newlines
</span>    process(line)

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS
</span>lines = [re.sub(r<span class="string">"^([^\012\015]*)(\012\015?|\015\012?)"</span>, <span class="string">""</span>, line) 
         <span class="keyword">for</span> line <span class="keyword">in</span> <span class="py-builtins">file</span>(fname)]
<span class="comment-delimiter">#</span><span class="comment">#-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="hashes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="fileaccess.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Hashes</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>File Access</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>