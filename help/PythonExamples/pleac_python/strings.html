<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Strings</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Python
"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="PLEAC-Python
"
HREF="index.html"><LINK
REL="NEXT"
TITLE="Numbers"
HREF="numbers.html"><style type="text/css">    <!--
      .comment {
        /* font-lock-comment-face */
        color: #bebebe;
      }
      .comment-delimiter {
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #b2dfee;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #ffa500;
      }
      .py-builtins {
        /* py-builtins-face */
        color: #ffa500;
      }
      .py-pseudo-keyword {
        /* py-pseudo-keyword-face */
        color: #ffa500;
      }
      .string {
        /* font-lock-string-face */
        color: #00cd00;
      }
      .type {
        /* font-lock-type-face */
        color: #98fb98;
      }
    -->
    </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Python
</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="numbers.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="STRINGS"
>1. Strings</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN14"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mystr = <span class="string">"\n"</span>   <span class="comment-delimiter"># </span><span class="comment">a newline character
</span>mystr = r<span class="string">"\n"</span>  <span class="comment-delimiter"># </span><span class="comment">two characters, \ and n
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mystr = <span class="string">"Jon 'Maddog' Orwant"</span>  <span class="comment-delimiter"># </span><span class="comment">literal single quote inside double quotes
</span>mystr = <span class="string">'Jon "Maddog" Orwant'</span>  <span class="comment-delimiter"># </span><span class="comment">literal double quote inside single quotes
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mystr = <span class="string">'Jon \'Maddog\' Orwant'</span>  <span class="comment-delimiter"># </span><span class="comment">escaped single quote
</span>mystr = <span class="string">"Jon \"Maddog\" Orwant"</span>  <span class="comment-delimiter"># </span><span class="comment">escaped double quote
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mystr = <span class="string">"""
This is a multiline string literal
enclosed in triple double quotes.
"""</span>
mystr = <span class="string">'''
And this is a multiline string literal
enclosed in triple single quotes.
'''</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN17"
>Accessing Substrings</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
<span class="comment-delimiter"># </span><span class="comment">get a 5-char string, skip 3, then grab 2 8-char strings, then the rest
</span><span class="comment-delimiter"># </span><span class="comment">Note that struct.unpack cannot use * for an unknown length.
</span><span class="comment-delimiter"># </span><span class="comment">See http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/65224
</span><span class="keyword">import</span> struct
(lead, s1, s2), tail = struct.unpack(<span class="string">"5s 3x 8s 8s"</span>, data[:24]), data[24:]

<span class="comment-delimiter"># </span><span class="comment">split at five-char boundaries
</span>fivers = struct.unpack(<span class="string">"5s"</span> * (<span class="py-builtins">len</span>(data)//5), data)
fivers = <span class="keyword">print</span> [x[i*5:i*5+5] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="py-builtins">range</span>(len(x)/5)]

<span class="comment-delimiter"># </span><span class="comment">chop string into individual characters
</span>chars = <span class="py-builtins">list</span>(data)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mystr = <span class="string">"This is what you have"</span>
<span class="comment-delimiter">#       </span><span class="comment">+012345678901234567890  Indexing forwards  (left to right)
</span><span class="comment-delimiter">#        </span><span class="comment">109876543210987654321- Indexing backwards (right to left)
</span><span class="comment-delimiter">#         </span><span class="comment">note that 0 means 10 or 20, etc. above
</span>
first = mystr[0]                            <span class="comment-delimiter"># </span><span class="comment">"T"
</span>start = mystr[5:7]                          <span class="comment-delimiter"># </span><span class="comment">"is"
</span>rest = mystr[13:]                           <span class="comment-delimiter"># </span><span class="comment">"you have"
</span>last = mystr[-1]                            <span class="comment-delimiter"># </span><span class="comment">"e"
</span>end = mystr[-4:]                            <span class="comment-delimiter"># </span><span class="comment">"have"
</span>piece = mystr[-8:-5]                        <span class="comment-delimiter"># </span><span class="comment">"you"
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">Python strings are immutable.
</span><span class="comment-delimiter"># </span><span class="comment">In general, you should just do piecemeal reallocation:
</span>mystr = <span class="string">"This is what you have"</span>
mystr = mystr[:5] + <span class="string">"wasn't"</span> + mystr[7:]

<span class="comment-delimiter"># </span><span class="comment">Or replace and reallocate
</span>mystr = <span class="string">"This is what you have"</span>
mystr = mystr.replace(<span class="string">" is "</span>, <span class="string">" wasn't "</span>)

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS: In-place modification could be done using character arrays
</span><span class="keyword">import</span> array
mystr = array.array(<span class="string">"c"</span>, <span class="string">"This is what you have"</span>)
mystr[5:7] = array.array(<span class="string">"c"</span>, <span class="string">"wasn't"</span>)
<span class="comment-delimiter"># </span><span class="comment">mystr is now array('c', "This wasn't what you have")
</span>
<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS: It could also be done using MutableString 
</span><span class="keyword">from</span> UserString <span class="keyword">import</span> MutableString
mystr = MutableString(<span class="string">"This is what you have"</span>)
mystr[-12:] = <span class="string">"ondrous"</span>
<span class="comment-delimiter"># </span><span class="comment">mystr is now "This is wondrous"
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">you can test simple substrings with "in" (for regex matching see ch.6):
</span><span class="keyword">if</span> txt <span class="keyword">in</span> mystr[-10:]:
    <span class="keyword">print</span> <span class="string">"'%s' found in last 10 characters"</span>%txt

<span class="comment-delimiter"># </span><span class="comment">Or use the startswith() and endswith() string methods:
</span><span class="keyword">if</span> mystr.startswith(txt):
    <span class="keyword">print</span> <span class="string">"%s starts with %s."</span>%(mystr, txt)
<span class="keyword">if</span> mystr.endswith(txt):
    <span class="keyword">print</span> <span class="string">"%s ends with %s."</span>%(mystr, txt)

<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN20"
>Establishing a Default Value</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">Introductory Note: quite a bit of this section is not terribly Pythonic
</span><span class="comment-delimiter"># </span><span class="comment">as names must be set before being used. For instance, unless myvar has 
</span><span class="comment-delimiter"># </span><span class="comment">been previously defined, these next lines will all raise NameError:
</span>myvar = myvar <span class="keyword">or</span> some_default
myvar2 = myvar <span class="keyword">or</span> some_default
myvar |= some_default          <span class="comment-delimiter"># </span><span class="comment">bitwise-or, not logical-or - for demo
</span>
<span class="comment-delimiter"># </span><span class="comment">The standard way of setting a default is often:
</span>myvar = default_value
<span class="keyword">if</span> some_condition:
    <span class="keyword">pass</span>                     <span class="comment-delimiter"># </span><span class="comment">code which may set myvar to something else
</span>
<span class="comment-delimiter"># </span><span class="comment">if myvar is returned from a function and may be empty/None, then use:
</span>myvar = somefunc()
<span class="keyword">if</span> <span class="keyword">not</span> myvar:
    myvar = default_value

<span class="comment-delimiter"># </span><span class="comment">If you want a default value that can be overridden by the person calling 
</span><span class="comment-delimiter"># </span><span class="comment">your code, you can often wrap it in a function with a named parameter:
</span><span class="keyword">def</span> <span class="function-name">myfunc</span>(myvar=<span class="string">"a"</span>):
   <span class="keyword">return</span> myvar + <span class="string">"b"</span>
<span class="keyword">print</span> myfunc(), myfunc(<span class="string">"c"</span>)
<span class="comment-delimiter">#</span><span class="comment">=&gt; ab cb
</span>
<span class="comment-delimiter"># </span><span class="comment">Note, though, that this won't work for mutable objects such as lists or
</span><span class="comment-delimiter"># </span><span class="comment">dicts that are mutated in the function as the object is only created once 
</span><span class="comment-delimiter"># </span><span class="comment">and repeated calls to the same function will return the same object.  This
</span><span class="comment-delimiter"># </span><span class="comment">can be desired behaviour however - see section 10.3, for instance.
</span><span class="keyword">def</span> <span class="function-name">myfunc</span>(myvar=[]):
    myvar.append(<span class="string">"x"</span>)
    <span class="keyword">return</span> myvar
<span class="keyword">print</span> myfunc(), myfunc()
<span class="comment-delimiter">#</span><span class="comment">=&gt; ['x'] ['x', 'x']
</span>
<span class="comment-delimiter"># </span><span class="comment">You need to do:
</span><span class="keyword">def</span> <span class="function-name">myfunc</span>(myvar=<span class="py-pseudo-keyword">None</span>):
    <span class="keyword">if</span> myvar <span class="keyword">is</span> <span class="py-pseudo-keyword">None</span>:
        myvar = []
    myvar.append(<span class="string">"x"</span>)
    <span class="keyword">return</span> myvar
<span class="keyword">print</span> myfunc(), myfunc()
<span class="comment-delimiter">#</span><span class="comment">=&gt; ['x'] ['x']
</span>
<span class="comment-delimiter">#</span><span class="comment">=== Perl Equivalencies start here
</span><span class="comment-delimiter"># </span><span class="comment">use b if b is true, otherwise use c
</span>a = b <span class="keyword">or</span> c

<span class="comment-delimiter"># </span><span class="comment">as that is a little tricksy, the following may be preferred:
</span><span class="keyword">if</span> b:
    a = b
<span class="keyword">else:</span>
    a = c

<span class="comment-delimiter"># </span><span class="comment">set x to y unless x is already true
</span><span class="keyword">if</span> <span class="keyword">not</span> x:
    x = y
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">use b if b is defined, else c
</span><span class="keyword">try:</span>
    a = b
<span class="keyword">except</span> <span class="py-builtins">NameError</span>:
    a = c
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>foo = bar <span class="keyword">or</span> <span class="string">"DEFAULT VALUE"</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">To get a user (for both UNIX and Windows), use:
</span><span class="keyword">import</span> getpass
user = getpass.getuser()

<span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS: find the user name on Unix systems 
</span><span class="keyword">import</span> os
user = os.environ.get(<span class="string">"USER"</span>)
<span class="keyword">if</span> user <span class="keyword">is</span> <span class="py-pseudo-keyword">None</span>:
    user = os.environ.get(<span class="string">"LOGNAME"</span>)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">if</span> <span class="keyword">not</span> starting_point:
    starting_point = <span class="string">"Greenwich"</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">if</span> <span class="keyword">not</span> a:         <span class="comment-delimiter"># </span><span class="comment">copy only if empty
</span>    a = b

<span class="keyword">if</span> b:             <span class="comment-delimiter"># </span><span class="comment">assign b if nonempty, else c
</span>    a = b
<span class="keyword">else:</span>
    a = c
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN23"
>Exchanging Values Without Using Temporary Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>v1, v2 = v2, v1
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">DON'T DO THIS:
</span>temp = a
a = b
b = temp
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>a = <span class="string">"alpha"</span>
b = <span class="string">"omega"</span>
a, b = b, a   <span class="comment-delimiter"># </span><span class="comment">the first shall be last -- and versa vice 
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>alpha, beta, production = <span class="string">"January March August"</span>.split()
alpha, beta, production = beta, production, alpha
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN26"
>Converting Between ASCII Characters and Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>num = <span class="py-builtins">ord</span>(char)
char = <span class="py-builtins">chr</span>(num)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>char = <span class="string">"%c"</span> % num
<span class="keyword">print</span> <span class="string">"Number %d is character %c"</span> % (num, num)
<span class="keyword">print</span> <span class="string">"Number %(n)d is character %(n)c"</span> % {<span class="string">"n"</span>: num}
<span class="keyword">print</span> <span class="string">"Number %(num)d is character %(num)c"</span> % <span class="py-builtins">locals</span>()
<span class="comment-delimiter">#</span><span class="comment">=&gt; Number 101 is character e
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>ascii_character_numbers = [<span class="py-builtins">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">"sample"</span>]
<span class="keyword">print</span> ascii_character_numbers
<span class="comment-delimiter">#</span><span class="comment">=&gt; [115, 97, 109, 112, 108, 101]
</span>
word = <span class="string">""</span>.join([<span class="py-builtins">chr</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> ascii_character_numbers])
word = <span class="string">""</span>.join([<span class="py-builtins">chr</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> [115, 97, 109, 112, 108, 101]])
<span class="keyword">print</span> word
<span class="comment-delimiter">#</span><span class="comment">=&gt; sample
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>hal = <span class="string">"HAL"</span>
ibm = <span class="string">""</span>.join([<span class="py-builtins">chr</span>(ord(c)+1) <span class="keyword">for</span> c <span class="keyword">in</span> hal]) <span class="comment-delimiter"># </span><span class="comment">add one to each ASCII value
</span><span class="keyword">print</span> ibm   
<span class="comment-delimiter">#</span><span class="comment">=&gt; IBM
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN29"
>Processing a String One Character at a Time</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mylist = <span class="py-builtins">list</span>(mystr)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">for</span> char <span class="keyword">in</span> mystr:
    <span class="keyword">pass</span> <span class="comment-delimiter"># </span><span class="comment">do something with char
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mystr = <span class="string">"an apple a day"</span>
uniq = sorted(set(mystr))
<span class="keyword">print</span> <span class="string">"unique chars are: '%s'"</span> % <span class="string">""</span>.join(uniq)
<span class="comment-delimiter">#</span><span class="comment">=&gt; unique chars are: ' adelnpy'
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>ascvals = [<span class="py-builtins">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> mystr]
<span class="keyword">print</span> <span class="string">"total is %s for '%s'."</span>%(<span class="py-builtins">sum</span>(ascvals), mystr)
<span class="comment-delimiter">#</span><span class="comment">=&gt; total is 1248 for 'an apple a day'.
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">sysv checksum
</span><span class="keyword">def</span> <span class="function-name">checksum</span>(myfile):
    values = [<span class="py-builtins">ord</span>(c) <span class="keyword">for</span> line <span class="keyword">in</span> myfile <span class="keyword">for</span> c <span class="keyword">in</span> line]
    <span class="keyword">return</span> <span class="py-builtins">sum</span>(values)%(2**16) - 1

<span class="keyword">import</span> fileinput
<span class="keyword">print</span> checksum(fileinput.input())   <span class="comment-delimiter"># </span><span class="comment">data from sys.stdin
</span>
<span class="comment-delimiter"># </span><span class="comment">Using a function means any iterable can be checksummed:
</span><span class="keyword">print</span> checksum(<span class="py-builtins">open</span>(<span class="string">"C:/test.txt"</span>)  <span class="comment-delimiter"># </span><span class="comment">data from file
</span><span class="keyword">print</span> checksum(<span class="string">"sometext"</span>)          <span class="comment-delimiter"># </span><span class="comment">data from string
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">slowcat - emulate a   s l o w  line printer
</span><span class="comment-delimiter"># </span><span class="comment">usage: slowcat [- DELAY] [files ...]
</span><span class="keyword">import</span> sys, select
<span class="keyword">import</span> re
DELAY = 1
<span class="keyword">if</span> re.match(<span class="string">"^-\d+$"</span>,sys.argv[1]):
    DELAY=-<span class="py-builtins">int</span>(sys.argv[1])
    <span class="keyword">del</span> sys.argv[1]
<span class="keyword">for</span> ln <span class="keyword">in</span> fileinput.input():
    <span class="keyword">for</span> c <span class="keyword">in</span> ln:
        sys.stdout.write(c)
        sys.stdout.flush()
        select.select([],[],[], 0.005 * DELAY)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32"
>Reversing a String by Word or Character</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">2.3+ only
</span>revchars = mystr[::-1]  <span class="comment-delimiter"># </span><span class="comment">extended slice - step is -1
</span>revwords = <span class="string">" "</span>.join(mystr.split(<span class="string">" "</span>)[::-1])

<span class="comment-delimiter"># </span><span class="comment">pre 2.3 version:
</span>mylist = <span class="py-builtins">list</span>(mystr)
mylist.reverse()
revbytes = <span class="string">""</span>.join(mylist)

mylist = mystr.split()
mylist.reverse()
revwords = <span class="string">' '</span>.join(mylist)

<span class="comment-delimiter"># </span><span class="comment">Alternative version using reversed():
</span>revchars = <span class="string">""</span>.join(reversed(mystr))
revwords = <span class="string">" "</span>.join(reversed(mystr.split(<span class="string">" "</span>)))

<span class="comment-delimiter"># </span><span class="comment">reversed() makes an iterator, which means that the reversal
</span><span class="comment-delimiter"># </span><span class="comment">happens as it is consumed.  This means that "print reversed(mystr)" is not
</span><span class="comment-delimiter"># </span><span class="comment">the same as mystr[::-1].  Standard usage is:
</span><span class="keyword">for</span> char <span class="keyword">in</span> reversed(mystr):
   <span class="keyword">pass</span>  <span class="comment-delimiter"># </span><span class="comment">... do something
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">2.3+ only
</span>word = <span class="string">"reviver"</span>
is_palindrome = (word == word[::-1])
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">Generator version
</span><span class="keyword">def</span> <span class="function-name">get_palindromes</span>(fname):
    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="py-builtins">open</span>(fname):
        word = line.rstrip()
        <span class="keyword">if</span> <span class="py-builtins">len</span>(word) &gt; 5 <span class="keyword">and</span> word == word[::-1]:
            <span class="keyword">yield</span> word
long_palindromes = <span class="py-builtins">list</span>(get_palindromes(<span class="string">"/usr/share/dict/words"</span>))

<span class="comment-delimiter"># </span><span class="comment">Simpler old-style version using 2.2 string reversal
</span><span class="keyword">def</span> <span class="function-name">rev_string</span>(mystr):
    mylist = <span class="py-builtins">list</span>(mystr)
    mylist.reverse()
    <span class="keyword">return</span> <span class="string">""</span>.join(mylist)

long_palindromes=[]
<span class="keyword">for</span> line <span class="keyword">in</span> <span class="py-builtins">open</span>(<span class="string">"/usr/share/dict/words"</span>):
    word = line.rstrip()
    <span class="keyword">if</span> <span class="py-builtins">len</span>(word) &gt; 5 <span class="keyword">and</span> word == rev_string(word):
        long_palindromes.append(word)
<span class="keyword">print</span> long_palindromes
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN35"
>Expanding and Compressing Tabs</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mystr.expandtabs()
mystr.expandtabs(4)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN38"
>Expanding Variables in User Input</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>text = <span class="string">"I am %(rows)s high and %(cols)s long"</span>%{<span class="string">"rows"</span>:24, <span class="string">"cols"</span>:80)
<span class="keyword">print</span> text
<span class="comment-delimiter">#</span><span class="comment">=&gt; I am 24 high and 80 long
</span>
rows, cols = 24, 80
text = <span class="string">"I am %(rows)s high and %(cols)s long"</span>%<span class="py-builtins">locals</span>()
<span class="keyword">print</span> text
<span class="comment-delimiter">#</span><span class="comment">=&gt; I am 24 high and 80 long
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">import</span> re
<span class="keyword">print</span> re.sub(<span class="string">"\d+"</span>, <span class="keyword">lambda</span> i: <span class="py-builtins">str</span>(2 * <span class="py-builtins">int</span>(i.group(0))), <span class="string">"I am 17 years old"</span>)
<span class="comment-delimiter">#</span><span class="comment">=&gt; I am 34 years old
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">expand variables in text, but put an error message in
</span><span class="comment-delimiter"># </span><span class="comment">if the variable isn't defined
</span><span class="keyword">class</span> <span class="type">SafeDict</span>(dict):
    <span class="keyword">def</span> <span class="function-name">__getitem__</span>(<span class="py-pseudo-keyword">self</span>, key):
        <span class="keyword">return</span> <span class="py-pseudo-keyword">self</span>.get(key, <span class="string">"[No Variable: %s]"</span>%key)
    
hi = <span class="string">"Hello"</span>
text = <span class="string">"%(hi)s and %(bye)s!"</span>%SafeDict(<span class="py-builtins">locals</span>())
<span class="keyword">print</span> text
<span class="comment-delimiter">#</span><span class="comment">=&gt; Hello and [No Variable: bye]!
</span>
<span class="comment-delimiter">#</span><span class="comment">If you don't need a particular error message, just use the Template class:
</span><span class="keyword">from</span> string <span class="keyword">import</span> Template
x = Template(<span class="string">"$hi and $bye!"</span>)
hi = <span class="string">"Hello"</span>
<span class="keyword">print</span> x.safe_substitute(<span class="py-builtins">locals</span>())
<span class="comment-delimiter">#</span><span class="comment">=&gt; Hello and $bye!
</span><span class="keyword">print</span> x.substitute(<span class="py-builtins">locals</span>()) <span class="comment-delimiter"># </span><span class="comment">will throw a KeyError
</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41"
>Controlling Case</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mystr = <span class="string">"bo peep"</span>.upper()  <span class="comment-delimiter"># </span><span class="comment">BO PEEP
</span>mystr = mystr.lower()      <span class="comment-delimiter"># </span><span class="comment">bo peep
</span>mystr = mystr.capitalize() <span class="comment-delimiter"># </span><span class="comment">Bo peep
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>beast = <span class="string">"python"</span>
caprest = beast.capitalize().swapcase() <span class="comment-delimiter"># </span><span class="comment">pYTHON
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">print</span> <span class="string">"thIS is a loNG liNE"</span>.title()
<span class="comment-delimiter">#</span><span class="comment">=&gt; This Is A Long Line
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">if</span> a.upper() == b.upper():
    <span class="keyword">print</span> <span class="string">"a and b are the same"</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">import</span> random
<span class="keyword">def</span> <span class="function-name">randcase_one</span>(letter):
    <span class="keyword">if</span> random.randint(0,5):   <span class="comment-delimiter"># </span><span class="comment">True on 1, 2, 3, 4
</span>        <span class="keyword">return</span> letter.lower()
    <span class="keyword">else:</span>
        <span class="keyword">return</span> letter.upper()

<span class="keyword">def</span> <span class="function-name">randcase</span>(myfile):
    <span class="keyword">for</span> line <span class="keyword">in</span> myfile:
        <span class="keyword">yield</span> <span class="string">""</span>.join(randcase_one(letter) <span class="keyword">for</span> letter <span class="keyword">in</span> line[:-1])

<span class="keyword">for</span> line <span class="keyword">in</span> randcase(myfile):
    <span class="keyword">print</span> line
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN44"
>Interpolating Functions and Expressions Within Strings</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="string">"I have %d guanacos."</span> % (n + 1)
<span class="keyword">print</span> <span class="string">"I have"</span>, n+1, <span class="string">"guanacos."</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment">Python templates disallow in-string calculations (see PEP 292)
</span><span class="keyword">from</span> string <span class="keyword">import</span> Template

email_template = Template(<span class="string">"""\
To: $address
From: Your Bank
CC: $cc_number
Date: $date

Dear $name,

Today you bounced check number $checknum to us.
Your account is now closed.

Sincerely,
the management
"""</span>)

<span class="keyword">import</span> random
<span class="keyword">import</span> datetime

person = {<span class="string">"address"</span>:<span class="string">"Joe@somewhere.com"</span>,
          <span class="string">"name"</span>: <span class="string">"Joe"</span>,
          <span class="string">"cc_number"</span> : 1234567890,
          <span class="string">"checknum"</span> : 500+random.randint(0,99)}

<span class="keyword">print</span> email_template.substitute(person, date=datetime.date.today())
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN47"
>Indenting Here Documents</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">indenting here documents
</span><span class="comment-delimiter">#</span><span class="comment">
</span><span class="comment-delimiter"># </span><span class="comment">in python multiline strings can be used as here documents
</span>var = <span class="string">"""
      your text
      goes here
      """</span>

<span class="comment-delimiter"># </span><span class="comment">using regular expressions
</span><span class="keyword">import</span> re
re_leading_blanks = re.compile(<span class="string">"^\s+"</span>,re.MULTILINE)
var1 = re_leading_blanks.sub(<span class="string">""</span>,var)[:-1]

<span class="comment-delimiter"># </span><span class="comment">using string methods 
</span><span class="comment-delimiter"># </span><span class="comment">split into lines, use every line except first and last, left strip and rejoin.
</span>var2 = <span class="string">"\n"</span>.join([line.lstrip() <span class="keyword">for</span> line <span class="keyword">in</span> var.split(<span class="string">"\n"</span>)[1:-1]])

poem = <span class="string">"""
       Here's your poem:
       Now far ahead the Road has gone,
          And I must follow, if I can,
       Pursuing it with eager feet,
          Until it joins some larger way
       Where many paths and errand meet.
          And whither then? I cannot say.
               --Bilbo in /usr/src/perl/pp_ctl.c  
       """</span>

<span class="keyword">import</span> textwrap
<span class="keyword">print</span> textwrap.dedent(poem)[1:-1]
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>    </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN50"
>Reformatting Paragraphs</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">from</span> textwrap <span class="keyword">import</span> wrap 
output = wrap(para,
              initial_indent=leadtab
              subsequent_indent=nexttab)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/env python
</span><span class="comment-delimiter"># </span><span class="comment">wrapdemo - show how textwrap works
</span>
txt = <span class="string">"""\
Folding and splicing is the work of an editor,
not a mere collection of silicon
and
mobile electrons!
"""</span>

<span class="keyword">from</span> textwrap <span class="keyword">import</span> TextWrapper

wrapper = TextWrapper(width=20,
                      initial_indent=<span class="string">" "</span>*4,
                      subsequent_indent=<span class="string">" "</span>*2)

<span class="keyword">print</span> <span class="string">"0123456789"</span> * 2
<span class="keyword">print</span> wrapper.fill(txt)

<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="string">"""Expected result:

01234567890123456789
    Folding and
  splicing is the
  work of an editor,
  not a mere
  collection of
  silicon and mobile
  electrons!
"""</span>

<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">merge multiple lines into one, then wrap one long line
</span>
<span class="keyword">from</span> textwrap <span class="keyword">import</span> fill
<span class="keyword">import</span> fileinput

<span class="keyword">print</span> fill(<span class="string">""</span>.join(fileinput.input()))

<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">Term::ReadKey::GetTerminalSize() isn't in the Perl standard library. 
</span><span class="comment-delimiter"># </span><span class="comment">It isn't in the Python standard library either. Michael Hudson's 
</span><span class="comment-delimiter"># </span><span class="comment">recipe from python-list #530228 is shown here.
</span><span class="comment-delimiter"># </span><span class="comment">(http://aspn.activestate.com/ASPN/Mail/Message/python-list/530228)
</span><span class="comment-delimiter"># </span><span class="comment">Be aware that this will work on Unix but not on Windows.
</span>
<span class="keyword">from</span> termwrap <span class="keyword">import</span> wrap
<span class="keyword">import</span> struct, fcntl
<span class="keyword">def</span> <span class="function-name">getheightwidth</span>():
    height, width = struct.unpack(
        <span class="string">"hhhh"</span>, fcntl.ioctl(0, TERMIOS.TIOCGWINSZ ,<span class="string">"\000"</span>*8))[0:2]
    <span class="keyword">return</span> height, width

<span class="comment-delimiter"># </span><span class="comment">PERL &lt;&gt;, $/, $\ emulation
</span><span class="keyword">import</span> fileinput
<span class="keyword">import</span> re

_, width = getheightwidth()
<span class="keyword">for</span> para <span class="keyword">in</span> re.split(r<span class="string">"\n{2,}"</span>, <span class="string">""</span>.join(fileinput.input())):
    <span class="keyword">print</span> fill(para, width)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN53"
>Escaping Characters</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mystr = <span class="string">'''Mom said, "Don'</span>t do that.<span class="string">"'''  #"</span>
re.sub(<span class="string">"['\"]"</span>, <span class="keyword">lambda</span> i: <span class="string">"\\"</span> + i.group(0), mystr)
re.sub(<span class="string">"[A-Z]"</span>, <span class="keyword">lambda</span> i: <span class="string">"\\"</span> + i.group(0), mystr)
re.sub(<span class="string">"\W"</span>, <span class="keyword">lambda</span> i: <span class="string">"\\"</span> + i.group(0), <span class="string">"is a test!"</span>) <span class="comment-delimiter"># </span><span class="comment">no function like quotemeta?
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN56"
>Trimming Blanks from the Ends of a String</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>mystr = mystr.lstrip() <span class="comment-delimiter"># </span><span class="comment">left
</span>mystr = mystr.rstrip() <span class="comment-delimiter"># </span><span class="comment">right
</span>mystr = mystr.strip()  <span class="comment-delimiter"># </span><span class="comment">both ends
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN59"
>Parsing Comma-Separated Data</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">import</span> csv
<span class="keyword">def</span> <span class="function-name">parse_csv</span>(line):
    reader = csv.reader([line], escapechar=<span class="string">'\\'</span>)
    <span class="keyword">return</span> reader.next()

line = <span class="string">'''XYZZY,"","O'</span>Reilly, Inc<span class="string">","</span>Wall, Larry<span class="string">","</span>a \\<span class="string">"glug\\"</span> bit,<span class="string">",5,"</span>Error, Core Dumped,<span class="string">",''' #"</span>

fields = parse_csv(line)

<span class="keyword">for</span> i, field <span class="keyword">in</span> <span class="py-builtins">enumerate</span>(fields):
    <span class="keyword">print</span> <span class="string">"%d : %s"</span> % (i, field)

<span class="comment-delimiter"># </span><span class="comment">pre-2.3 version of parse_csv
</span><span class="keyword">import</span> re
<span class="keyword">def</span> <span class="function-name">parse_csv</span>(text):
    pattern = re.compile(<span class="string">'''"([^"\\\]*(?:\\\.[^"\\\]*)*)",?|([^,]+),?|,'''</span>)
    mylist = [<span class="string">""</span>.join(elem) 
              <span class="keyword">for</span> elem <span class="keyword">in</span> re.findall(pattern, text)]
    <span class="keyword">if</span> text[-1] == <span class="string">","</span>: 
        mylist += [<span class="string">''</span>]
    <span class="keyword">return</span> mylist

<span class="comment-delimiter"># </span><span class="comment">cvs.reader is meant to work for many lines, something like:
</span><span class="comment-delimiter"># </span><span class="comment">(NB: in Python default, quotechar is *not* escaped by backslash,
</span><span class="comment-delimiter">#      </span><span class="comment">but doubled instead. That's what Excel does.)
</span><span class="keyword">for</span> fields <span class="keyword">in</span> cvs.reader(lines, dialect=<span class="string">"some"</span>):
    <span class="keyword">for</span> num, field <span class="keyword">in</span> <span class="py-builtins">enumerate</span>(fields):
        <span class="keyword">print</span> num, <span class="string">":"</span>, field
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN62"
>Soundex Matching</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">def</span> <span class="function-name">soundex</span>(name, len=4):
    <span class="string">""" soundex module conforming to Knuth's algorithm
        implementation 2000-12-24 by Gregory Jorgensen
        public domain
    """</span>

    <span class="comment-delimiter"># </span><span class="comment">digits holds the soundex values for the alphabet
</span>    digits = <span class="string">'01230120022455012623010202'</span>
    sndx = <span class="string">''</span>
    fc = <span class="string">''</span>

    <span class="comment-delimiter"># </span><span class="comment">translate alpha chars in name to soundex digits
</span>    <span class="keyword">for</span> c <span class="keyword">in</span> name.upper():
        <span class="keyword">if</span> c.isalpha():
            <span class="keyword">if</span> <span class="keyword">not</span> fc: 
                fc = c   <span class="comment-delimiter"># </span><span class="comment">remember first letter
</span>            d = digits[<span class="py-builtins">ord</span>(c)-<span class="py-builtins">ord</span>(<span class="string">'A'</span>)]
            <span class="comment-delimiter"># </span><span class="comment">duplicate consecutive soundex digits are skipped
</span>            <span class="keyword">if</span> <span class="keyword">not</span> sndx <span class="keyword">or</span> (d != sndx[-1]):
                sndx += d

    <span class="comment-delimiter"># </span><span class="comment">replace first digit with first alpha character
</span>    sndx = fc + sndx[1:]

    <span class="comment-delimiter"># </span><span class="comment">remove all 0s from the soundex code
</span>    sndx = sndx.replace(<span class="string">'0'</span>,<span class="string">''</span>)

    <span class="comment-delimiter"># </span><span class="comment">return soundex code padded to len characters
</span>    <span class="keyword">return</span> (sndx + (<span class="py-builtins">len</span> * <span class="string">'0'</span>))[:len]

user = <span class="py-builtins">raw_input</span>(<span class="string">"Lookup user: "</span>)
<span class="keyword">if</span> user == <span class="string">""</span>:
    <span class="keyword">raise</span> <span class="py-builtins">SystemExit</span>

name_code = soundex(user)
<span class="keyword">for</span> line <span class="keyword">in</span> <span class="py-builtins">open</span>(<span class="string">"/etc/passwd"</span>):
    line = line.split(<span class="string">":"</span>)
    <span class="keyword">for</span> piece <span class="keyword">in</span> line[4].split():
        <span class="keyword">if</span> name_code == soundex(piece):
            <span class="keyword">print</span> <span class="string">"%s: %s\n"</span> % line[0], line[4])
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN65"
>Program: fixstyle</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">import</span> sys, fileinput, re

data = <span class="string">"""\
analysed        =&gt; analyzed
built-in        =&gt; builtin
chastized       =&gt; chastised
commandline     =&gt; command-line
de-allocate     =&gt; deallocate
dropin          =&gt; drop-in
hardcode        =&gt; hard-code
meta-data       =&gt; metadata
multicharacter  =&gt; multi-character
multiway        =&gt; multi-way
non-empty       =&gt; nonempty
non-profit      =&gt; nonprofit
non-trappable   =&gt; nontrappable
pre-define      =&gt; predefine
preextend       =&gt; pre-extend
re-compiling    =&gt; recompiling
reenter         =&gt; re-enter
turnkey         =&gt; turn-key
"""</span>
mydict = {}
<span class="keyword">for</span> line <span class="keyword">in</span> data.split(<span class="string">"\n"</span>):
    <span class="keyword">if</span> <span class="keyword">not</span> line.strip():
        <span class="keyword">continue</span>
    k, v = [word.strip() <span class="keyword">for</span> word <span class="keyword">in</span> line.split(<span class="string">"=&gt;"</span>)]
    mydict[k] = v
pattern_text = <span class="string">"("</span> + <span class="string">"|"</span>.join([re.escape(word) <span class="keyword">for</span> word <span class="keyword">in</span> mydict.keys()]) + <span class="string">")"</span>
pattern = re.compile(pattern_text)

args = sys.argv[1:]
verbose = 0
<span class="keyword">if</span> args <span class="keyword">and</span> args[0] == <span class="string">"-v"</span>:
    verbose = 1
    args = args[1:]

<span class="keyword">if</span> <span class="keyword">not</span> args:
    sys.stderr.write(<span class="string">"%s: Reading from stdin\n"</span> % sys.argv[0])

<span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input(args, inplace=1, backup=<span class="string">".orig"</span>):
    output = <span class="string">""</span>
    pos = 0
    <span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
        match = pattern.search(line, pos)
        <span class="keyword">if</span> <span class="keyword">not</span> match:
            output += line[pos:]
            <span class="keyword">break</span>
        output += line[pos:match.start(0)] + mydict[match.group(1)]
        pos = match.end(0)
    sys.stdout.write(output)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN68"
>Program: psgrep</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">psgrep - print selected lines of ps output by
</span><span class="comment-delimiter">#          </span><span class="comment">compiling user queries into code.
</span><span class="comment-delimiter">#</span><span class="comment">
</span><span class="comment-delimiter"># </span><span class="comment">examples :
</span><span class="comment-delimiter"># </span><span class="comment">psgrep "uid&lt;10"
</span><span class="keyword">import</span> sys, os, re

<span class="keyword">class</span> <span class="type">PsLineMatch</span>:
    <span class="comment-delimiter"># </span><span class="comment">each field from the PS header
</span>    fieldnames = (<span class="string">"flags"</span>,<span class="string">"uid"</span>,<span class="string">"pid"</span>,<span class="string">"ppid"</span>,<span class="string">"pri"</span>,<span class="string">"nice"</span>,<span class="string">"size"</span>, \
                  <span class="string">"rss"</span>,<span class="string">"wchan"</span>,<span class="string">"stat"</span>,<span class="string">"tty"</span>,<span class="string">"time"</span>,<span class="string">"command"</span>)
    numeric_fields = (<span class="string">"flags"</span>,<span class="string">"uid"</span>,<span class="string">"pid"</span>,<span class="string">"ppid"</span>,<span class="string">"pri"</span>,<span class="string">"nice"</span>,<span class="string">"size"</span>,<span class="string">"rss"</span>)
    <span class="keyword">def</span> <span class="function-name">__init__</span>(<span class="py-pseudo-keyword">self</span>):
        <span class="py-pseudo-keyword">self</span>._fields = {}

    <span class="keyword">def</span> <span class="function-name">new_line</span>(<span class="py-pseudo-keyword">self</span>, ln):
        <span class="py-pseudo-keyword">self</span>._ln = ln.rstrip()
        <span class="comment-delimiter"># </span><span class="comment">ps header for option "wwaxl" (different than in the perl code)
</span>        <span class="string">"""
          F   UID   PID  PPID PRI  NI   VSZ  RSS WCHAN  STAT TTY        TIME COMMAND"</span>
        004     0     1     0  15   0   448  236 schedu S    ?          0:07 init<span class="string">"
        .   .     .     .     .   .   .     .    .      .    .    .          .
        """</span>
        <span class="comment-delimiter"># </span><span class="comment">because only the last entry might contain blanks, splitting
</span>        <span class="comment-delimiter"># </span><span class="comment">is safe
</span>        data = <span class="py-pseudo-keyword">self</span>._ln.split(<span class="py-pseudo-keyword">None</span>,12)
        <span class="keyword">for</span> fn, elem <span class="keyword">in</span> <span class="py-builtins">zip</span>(<span class="py-pseudo-keyword">self</span>.fieldnames, data):
            <span class="keyword">if</span> fn <span class="keyword">in</span> <span class="py-pseudo-keyword">self</span>.numeric_fields:  <span class="comment-delimiter"># </span><span class="comment">make numbers integer 
</span>                <span class="py-pseudo-keyword">self</span>._fields[fn] = <span class="py-builtins">int</span>(elem)
            <span class="keyword">else:</span>
                <span class="py-pseudo-keyword">self</span>._fields[fn] = elem

    <span class="keyword">def</span> <span class="function-name">set_query</span>(<span class="py-pseudo-keyword">self</span>, args):
        <span class="comment-delimiter"># </span><span class="comment">assume args: "uid==500", "command ~ ^wm"
</span>        conds=[]
        m = re.compile(<span class="string">"(\w+)([=&lt;&gt;]+)(.+)"</span>)
        <span class="keyword">for</span> a <span class="keyword">in</span> args:
            <span class="keyword">try:</span>
                (field,op,val) = m.match(a).groups()
            <span class="keyword">except:</span>
                <span class="keyword">print</span> <span class="string">"can't understand query \"%s\""</span> % (a)
                <span class="keyword">raise</span> <span class="py-builtins">SystemExit</span>
            <span class="keyword">if</span> field <span class="keyword">in</span> <span class="py-pseudo-keyword">self</span>.numeric_fields:
                conds.append(a)
            <span class="keyword">else:</span>
                conds.append(<span class="string">"%s%s'%s'"</span>,(field,op,val))
        <span class="py-pseudo-keyword">self</span>._desirable = <span class="py-builtins">compile</span>(<span class="string">"(("</span>+<span class="string">")and("</span>.join(conds)+<span class="string">"))"</span>, <span class="string">"&lt;string&gt;"</span>,<span class="string">"eval"</span>)

    <span class="keyword">def</span> <span class="function-name">is_desirable</span>(<span class="py-pseudo-keyword">self</span>):
        <span class="keyword">return</span> <span class="py-builtins">eval</span>(<span class="py-pseudo-keyword">self</span>._desirable, {}, <span class="py-pseudo-keyword">self</span>._fields)

    <span class="keyword">def</span> <span class="function-name">__str__</span>(<span class="py-pseudo-keyword">self</span>):
        <span class="comment-delimiter"># </span><span class="comment">to allow "print".
</span>        <span class="keyword">return</span> <span class="py-pseudo-keyword">self</span>._ln

<span class="keyword">if</span> <span class="py-builtins">len</span>(sys.argv)&lt;=1:
    <span class="keyword">print</span> <span class="string">"""usage: %s criterion ...
    Each criterion is a Perl expression involving: 
    %s
    All criteria must be met for a line to be printed."""</span> \
    % (sys.argv[0], <span class="string">" "</span>.join(PsLineMatch().fieldnames))
    <span class="keyword">raise</span> <span class="py-builtins">SystemExit</span>

psln = PsLineMatch()
psln.set_query(sys.argv[1:])
p = os.popen(<span class="string">"ps wwaxl"</span>)
<span class="keyword">print</span> p.readline()[:-1]        <span class="comment-delimiter"># </span><span class="comment">emit header line
</span><span class="keyword">for</span> ln <span class="keyword">in</span> p.readlines():
    psln.new_line(ln)
    <span class="keyword">if</span> psln.is_desirable():
        <span class="keyword">print</span> psln
p.close()

<span class="comment-delimiter"># </span><span class="comment">alternatively one could consider every argument being a string and
</span><span class="comment-delimiter"># </span><span class="comment">support wildcards: "uid==500" "command~^wm" by means of re, but this
</span><span class="comment-delimiter"># </span><span class="comment">does not show dynamic python code generation, although re.compile
</span><span class="comment-delimiter"># </span><span class="comment">also precompiles.
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="numbers.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>PLEAC-Python
</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Numbers</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>