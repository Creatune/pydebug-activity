<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>File Contents</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Python
"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="File Access"
HREF="fileaccess.html"><LINK
REL="NEXT"
TITLE="Directories"
HREF="directories.html"><style type="text/css">    <!--
      .comment {
        /* font-lock-comment-face */
        color: #bebebe;
      }
      .comment-delimiter {
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #b2dfee;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #ffa500;
      }
      .py-builtins {
        /* py-builtins-face */
        color: #ffa500;
      }
      .py-pseudo-keyword {
        /* py-pseudo-keyword-face */
        color: #ffa500;
      }
      .string {
        /* font-lock-string-face */
        color: #00cd00;
      }
      .type {
        /* font-lock-type-face */
        color: #98fb98;
      }
    -->
    </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Python
</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="fileaccess.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="directories.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FILECONTENTS"
>8. File Contents</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN430"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">for</span> line <span class="keyword">in</span> DATAFILE:
    line = line.rstrip()
    size = <span class="py-builtins">len</span>(line)
    <span class="keyword">print</span> size        <span class="comment-delimiter"># </span><span class="comment">output size of line
</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">for</span> line <span class="keyword">in</span> datafile:
    <span class="keyword">print</span> length(line.rstrip())     <span class="comment-delimiter"># </span><span class="comment">output size of line
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>lines = datafile.readlines()
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>whole_file = myfile.read()
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment"># No direct equivalent in Python
</span><span class="comment-delimiter">#</span><span class="comment">% perl -040 -e '$word = &lt;&gt;; print "First word is $word\n";'
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment"># No direct equivalent in Python
</span><span class="comment-delimiter">#</span><span class="comment">% perl -ne 'BEGIN { $/="%%\n" } chomp; print if /Unix/i' fortune.dat
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>print&gt;&gt;myfile, <span class="string">"One"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>  <span class="comment-delimiter"># </span><span class="comment">"One two three"
</span><span class="keyword">print</span> <span class="string">"Baa baa black sheep."</span>         <span class="comment-delimiter"># </span><span class="comment">Sent to default output file
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="py-builtins">buffer</span> = myfile.read(4096)
rv = <span class="py-builtins">len</span>(buffer)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>myfile.truncate(length)
<span class="py-builtins">open</span>(<span class="string">"/tmp/%d.pid"</span> % os.getpid(), <span class="string">"a"</span>).truncate(length)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>pos = myfile.tell()
<span class="keyword">print</span> <span class="string">"I'm"</span>, pos, <span class="string">"bytes from the start of DATAFILE."</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>logfile.seek(0, 2)   <span class="comment-delimiter"># </span><span class="comment">Seek to the end
</span>datafile.seek(pos)   <span class="comment-delimiter"># </span><span class="comment">Seek to a given byte
</span>outfile.seek(-20, 1) <span class="comment-delimiter"># </span><span class="comment">Seek back 20 bytes
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>written = os.write(datafile.fileno(), mystr)
<span class="keyword">if</span> written != <span class="py-builtins">len</span>(mystr):
    warnings.warn(<span class="string">"only read %s bytes, not %s"</span> % (written, <span class="py-builtins">len</span>(mystr)))
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>pos = os.lseek(myfile.fileno(), 0, 1)       <span class="comment-delimiter"># </span><span class="comment">don't change position
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN433"
>Reading Lines with Continuation Characters</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">def</span> <span class="function-name">ContReader</span>(infile):
    lines = []
    <span class="keyword">for</span> line <span class="keyword">in</span> infile:
        line = line.rstrip()
        <span class="keyword">if</span> line.endswith(<span class="string">"\\"</span>):
            lines.append(line[:-1])
            <span class="keyword">continue</span>
        lines.append(line)
        <span class="keyword">yield</span> <span class="string">""</span>.join(lines)
        lines = []
    <span class="keyword">if</span> lines:
        <span class="keyword">yield</span> <span class="string">""</span>.join(lines)

<span class="keyword">for</span> line <span class="keyword">in</span> ContReader(datafile):
    <span class="keyword">pass</span> <span class="comment-delimiter"># </span><span class="comment">process full record in 'line' here
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN436"
>Counting Lines (or Paragraphs or Records) in a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">import</span> os
count = <span class="py-builtins">int</span>(os.popen(<span class="string">"wc -l &lt; "</span> + filename).read())
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">for</span> count, line <span class="keyword">in</span> <span class="py-builtins">enumerate</span>(open(filename)):
    <span class="keyword">pass</span>
count += 1  <span class="comment-delimiter"># </span><span class="comment">indexing is zero based
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>myfile = <span class="py-builtins">open</span>(filename)
count = 0
<span class="keyword">for</span> line <span class="keyword">in</span> myfile:
    count += 1
<span class="comment-delimiter"># </span><span class="comment">'count' now holds the number of lines read
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>myfile = <span class="py-builtins">open</span>(filename)
count = 0
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    line = myfile.readline()
    <span class="keyword">if</span> <span class="keyword">not</span> line:
        <span class="keyword">break</span>
    count += 1
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>count = 0
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    s = myfile.read(2**16)
    count += s.count(<span class="string">"\n"</span>)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">for</span> line, count <span class="keyword">in</span> <span class="py-builtins">zip</span>(open(filename), <span class="py-builtins">xrange</span>(1, sys.maxint)):
    <span class="keyword">pass</span>
<span class="comment-delimiter"># </span><span class="comment">'count' now holds the number of lines read
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">import</span> fileinput
fi = fileinput.FileInput(filename)
<span class="keyword">while</span> fi.readline(): <span class="keyword">pass</span>

count = fi.lineno()
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">def</span> <span class="function-name">SepReader</span>(infile, sep = <span class="string">"\n\n"</span>):
    text = infile.read(10000)
    <span class="keyword">if</span> <span class="keyword">not</span> text:
        <span class="keyword">return</span>
    <span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
        fields = text.split(sep)
        <span class="keyword">for</span> field <span class="keyword">in</span> fields[:-1]:
            <span class="keyword">yield</span> field
        text = fields[-1]
        new_text = infile.read(10000)
        <span class="keyword">if</span> <span class="keyword">not</span> new_text:
            <span class="keyword">yield</span> text
            <span class="keyword">break</span>
        text += new_text

para_count = 0
<span class="keyword">for</span> para <span class="keyword">in</span> SepReader(<span class="py-builtins">open</span>(filename)):
    para_count += 1
<span class="comment-delimiter"># </span><span class="comment">FIXME: For my test case (Python-pre2.2 README from CVS) this
</span><span class="comment-delimiter"># </span><span class="comment">returns 175 paragraphs while Perl returns 174.
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN439"
>Processing Every Word in a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:
    <span class="keyword">for</span> word <span class="keyword">in</span> line.split():
        <span class="keyword">pass</span> <span class="comment-delimiter"># </span><span class="comment">do something with 'chunk'
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>pat = re.compile(r<span class="string">"(\w[\w'-]*)"</span>)
<span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:
    pos = 0
    <span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
        match = pat.search(line, pos)
        <span class="keyword">if</span> <span class="keyword">not</span> match:
            <span class="keyword">break</span>
        pos = match.end(1)
        <span class="comment-delimiter"># </span><span class="comment">do something with match.group(1)
</span>
<span class="comment-delimiter"># </span><span class="comment">EXPERIMENTAL in the sre implementation but
</span><span class="comment-delimiter"># </span><span class="comment">likely to be included in future (post-2.2) releases.
</span>pat = re.compile(r<span class="string">"(\w[\w'-]*)"</span>)
<span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:
    scanner = pat.scanner(line)
    <span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
        match = scanner.search()
        <span class="keyword">if</span> <span class="keyword">not</span> match:
            <span class="keyword">break</span>
        <span class="comment-delimiter"># </span><span class="comment">do something with match.group(1)
</span>

<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">Make a word frequency count
</span><span class="keyword">import</span> fileinput, re
pat = re.compile(r<span class="string">"(\w[\w'-]*)"</span>)
seen = {}
<span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():
    pos = 0
    <span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
        match = pat.search(line, pos)
        <span class="keyword">if</span> <span class="keyword">not</span> match:
            <span class="keyword">break</span>
        pos = match.end(1)
        text = match.group(1).lower()
        seen[text] = seen.get(text, 0) + 1

<span class="comment-delimiter"># </span><span class="comment">output dict in a descending numeric sort of its values
</span><span class="keyword">for</span> text, count <span class="keyword">in</span> sorted(seen.items, key=<span class="keyword">lambda</span> item: item[1]):
    <span class="keyword">print</span> <span class="string">"%5d %s"</span> % (count, text)

<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">Line frequency count
</span><span class="keyword">import</span> fileinput, sys
seen = {}
<span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():
    text = line.lower()
    seen[text] = seen.get(text, 0) + 1

<span class="keyword">for</span> text, count <span class="keyword">in</span> sorted(seen.items, key=<span class="keyword">lambda</span> item: item[1]):
    sys.stdout.write(<span class="string">"%5d %s"</span> % (count, text))

<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN442"
>Reading a File Backwards by Line or Paragraph</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span>lines = myfile.readlines()
<span class="keyword">while</span> lines:
    line = lines.pop()
    <span class="comment-delimiter"># </span><span class="comment">do something with 'line'
</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">for</span> line <span class="keyword">in</span> reversed(myfile):
    <span class="keyword">pass</span>  <span class="comment-delimiter"># </span><span class="comment">do something with line
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="py-builtins">range</span>(len(lines)):
    line = lines[-i]
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">for</span> paragraph <span class="keyword">in</span> sorted(SepReader(infile)):
    <span class="keyword">pass</span> <span class="comment-delimiter"># </span><span class="comment">do something
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN445"
>Trailing a Growing File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">import</span> time
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    <span class="keyword">for</span> line <span class="keyword">in</span> infile:
        <span class="keyword">pass</span> <span class="comment-delimiter"># </span><span class="comment">do something with the line
</span>    time.sleep(SOMETIME)
    infile.seek(0, 1)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">import</span> time
naptime = 1

logfile = <span class="py-builtins">open</span>(<span class="string">"/tmp/logfile"</span>)
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    <span class="keyword">for</span> line <span class="keyword">in</span> logfile:
        <span class="keyword">print</span> line.rstrip()
    time.sleep(naptime)
    infile.seek(0, 1)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    curpos = logfile.tell()
    <span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
        line = logfile.readline()
        <span class="keyword">if</span> <span class="keyword">not</span> line:
            <span class="keyword">break</span>
        curpos = logfile.tell()
    sleep(naptime)
    logfile.seek(curpos, 0)  <span class="comment-delimiter"># </span><span class="comment">seek to where we had been
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">import</span> os
<span class="keyword">if</span> os.stat(LOGFILENAME).st_nlink == 0:
    <span class="keyword">raise</span> <span class="py-builtins">SystemExit</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN448"
>Picking a Random Line from a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">import</span> random, fileinput
text = <span class="py-pseudo-keyword">None</span>
<span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():
    <span class="keyword">if</span> random.randrange(fileinput.lineno()) == 0:
        text = line
<span class="comment-delimiter"># </span><span class="comment">'text' is the random line
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter"># </span><span class="comment">XXX is the perl code correct?  Where is the fortunes file opened?
</span><span class="keyword">import</span> sys
adage = <span class="py-pseudo-keyword">None</span>
<span class="keyword">for</span> i, rec <span class="keyword">in</span> <span class="py-builtins">enumerate</span>(SepReader(<span class="py-builtins">open</span>(<span class="string">"/usr/share/games/fortunes"</span>), <span class="string">"%\n"</span>)):
    <span class="keyword">if</span> random.randrange(i+1) == 0:
        adage = rec
<span class="keyword">print</span> adage
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN451"
>Randomizing All Lines</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">import</span> random
lines = data.readlines()
random.shuffle(lines)
<span class="keyword">for</span> line <span class="keyword">in</span> lines:
    <span class="keyword">print</span> line.rstrip()
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN454"
>Reading a Particular Line in a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">using efficient caching system
</span><span class="keyword">import</span> linecache
linecache.getline(filename, DESIRED_LINE_NUMBER)

<span class="comment-delimiter"># </span><span class="comment">or doing it more oldskool
</span>lineno = 0
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    line = infile.readline()
    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">or</span> lineno == DESIRED_LINE_NUMBER:
        <span class="keyword">break</span>
    lineno += 1
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>lines = infile.readlines()
line = lines[DESIRED_LINE_NUMBER]
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="py-builtins">range</span>(DESIRED_LINE_NUMBER):
    line = infile.readline()
    <span class="keyword">if</span> <span class="keyword">not</span> line:
        <span class="keyword">break</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
<span class="comment-delimiter">#</span><span class="comment"># Not sure what this thing is doing.  Allow fast access to a given
</span><span class="comment-delimiter">#</span><span class="comment"># line number?
</span>
<span class="comment-delimiter"># </span><span class="comment">usage: build_index(*DATA_HANDLE, *INDEX_HANDLE)
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN457"
>Processing Variable-Length Text Fields</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">given $RECORD with field separated by PATTERN,
</span><span class="comment-delimiter"># </span><span class="comment">extract @FIELDS.
</span>fields = re.split(pattern_string, text)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>pat = re.compile(pattern_string)
fields = pat.split(text)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>re.split(r<span class="string">"([+-])"</span>, <span class="string">"3+5-2"</span>)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>[3, <span class="string">'+'</span>, 5, <span class="string">'-'</span>, 2]
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>fields = record.split(<span class="string">":"</span>)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>fields = re.split(r<span class="string">":"</span>, record)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>fields = re.split(r<span class="string">"\s+"</span>, record)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>fields = record.split(<span class="string">" "</span>)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN460"
>Removing the Last Line of a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span>myfile = <span class="py-builtins">open</span>(filename, <span class="string">"r"</span>)
prev_pos = pos = 0
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    line = myfile.readline()
    <span class="keyword">if</span> <span class="keyword">not</span> line:
        <span class="keyword">break</span>
    prev_pos = pos
    pos = myfile.tell()
myfile = <span class="py-builtins">open</span>(filename, <span class="string">"a"</span>)
myfile.truncate(prev_pos)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN463"
>Processing Binary Files</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="py-builtins">open</span>(filename, <span class="string">"rb"</span>)
<span class="py-builtins">open</span>(filename, <span class="string">"wb"</span>)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>gifname = <span class="string">"picture.gif"</span>
gif_file = <span class="py-builtins">open</span>(gifname, <span class="string">"rb"</span>)

<span class="comment-delimiter"># </span><span class="comment">Don't think there's an equivalent for these in Python
</span><span class="comment-delimiter">#</span><span class="comment">binmode(GIF);               # now DOS won't mangle binary input from GIF
</span><span class="comment-delimiter">#</span><span class="comment">binmode(STDOUT);            # now DOS won't mangle binary output to STDOUT
</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    buff = gif.read(8 * 2**10)
    <span class="keyword">if</span> <span class="keyword">not</span> buff:
        <span class="keyword">break</span>
    sys.stdout.write(buff)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN466"
>Using Random-Access I/O</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span>address = recsize * recno
myfile.seek(address, 0)
<span class="py-builtins">buffer</span> = myfile.read(recsize)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>address = recsize * (recno-1)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN469"
>Updating a Random-Access File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">import</span> posixfile
address = recsize * recno
myfile.seek(address)
<span class="py-builtins">buffer</span> = myfile.read(recsize)
<span class="comment-delimiter"># </span><span class="comment">... work with the buffer, then turn it back into a string and ...
</span>myfile.seek(-recsize, posixfile.SEEK_CUR)
myfile.write(buffer)
myfile.close()
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment"># Not yet implemented
</span><span class="comment-delimiter"># </span><span class="comment">weekearly -- set someone's login date back a week
</span><span class="comment-delimiter"># </span><span class="comment">@@INCOMPLETE@@
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN472"
>Reading a String from a Binary File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment"># Note: this isn't optimal -- the 's+=c' may go O(N**2) so don't
</span><span class="comment-delimiter">#</span><span class="comment"># use for large strings.
</span>myfile.seek(addr)
s = <span class="string">""</span>
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    c = myfile.read(1)
    <span class="keyword">if</span> <span class="keyword">not</span> c <span class="keyword">or</span> c == <span class="string">"\0"</span>:
        <span class="keyword">break</span>
    s += c
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>myfile.seek(addr)
offset = 0
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    s = myfile.read(1000)
    x = s.find(<span class="string">"\0"</span>)
    <span class="keyword">if</span> x != -1:
        offset += x
        <span class="keyword">break</span>
    offset += <span class="py-builtins">len</span>(s)
    <span class="keyword">if</span> <span class="py-builtins">len</span>(s) != 1000:  <span class="comment-delimiter"># </span><span class="comment">EOF
</span>        <span class="keyword">break</span>
myfile.seek(addr)
s = myfile.read(offset - 1)
myfile.read(1)

<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment"># Not Implemented
</span><span class="comment-delimiter"># </span><span class="comment">bgets - get a string from an address in a binary file
</span><span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/perl
</span><span class="comment-delimiter"># </span><span class="comment">strings - pull strings out of a binary file
</span><span class="keyword">import</span> re, sys

<span class="comment-delimiter">#</span><span class="comment"># Assumes SepReader from above
</span>
pat = re.compile(r<span class="string">"([\040-\176\s]{4,})"</span>)
<span class="keyword">for</span> block <span class="keyword">in</span> SepReader(sys.stdin, <span class="string">"\0"</span>):
    pos = 0
    <span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
        match = pat.search(block, pos)
        <span class="keyword">if</span> <span class="keyword">not</span> match:
            <span class="keyword">break</span>
        <span class="keyword">print</span> match.group(1)
        pos = match.end(1)
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span> </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN475"
>Reading Fixed-Length Records</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span>
<span class="comment-delimiter"># </span><span class="comment">RECORDSIZE is the length of a record, in bytes.
</span><span class="comment-delimiter"># </span><span class="comment">TEMPLATE is the unpack template for the record
</span><span class="comment-delimiter"># </span><span class="comment">FILE is the file to read from
</span><span class="comment-delimiter"># </span><span class="comment">FIELDS is a tuple, one element per field
</span><span class="keyword">import</span> struct
RECORDSIZE= struct.calcsize(TEMPLATE)
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    record = FILE.read(RECORDSIZE):
    <span class="keyword">if</span> <span class="py-builtins">len</span>(record)!=RECORDSIZE:
        <span class="keyword">raise</span> <span class="string">"short read"</span>
    FIELDS = struct.unpack(TEMPLATE, record)
<span class="comment-delimiter"># </span><span class="comment">----
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN478"
>Reading Configuration Files</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">NOTE: to parse INI file, see the stanard ConfigParser module.
</span><span class="keyword">import</span> re
pat = re.compile(r<span class="string">"\s*=\s*"</span>)
<span class="keyword">for</span> line <span class="keyword">in</span> config_file:
    <span class="keyword">if</span> <span class="string">"#"</span> <span class="keyword">in</span> line:         <span class="comment-delimiter"># </span><span class="comment">no comments
</span>        line = line[:line.index(<span class="string">"#"</span>)]
    line = line.strip()     <span class="comment-delimiter"># </span><span class="comment">no leading or trailing white
</span>    <span class="keyword">if</span> <span class="keyword">not</span> line:            <span class="comment-delimiter"># </span><span class="comment">anything left?
</span>        <span class="keyword">continue</span>
    m = pat.search(line)
    var = line[:m.start()]
    value = line[m.end():]
    User_Preferences[var] = value</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN481"
>Testing a File for Trustworthiness</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="keyword">import</span> os

mode, ino, dev, nlink, uid, gid, size, \
atime, mtime, ctime = os.stat(filename)

mode &amp;= 07777               <span class="comment-delimiter"># </span><span class="comment">discard file type info
</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>info = os.stat(filename)
<span class="keyword">if</span> info.st_uid == 0:
    <span class="keyword">print</span> <span class="string">"Superuser owns"</span>, filename
<span class="keyword">if</span> info.st_atime &gt; info.st_mtime:
    <span class="keyword">print</span> filename, <span class="string">"has been read since it was written."</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="keyword">import</span> os
<span class="keyword">def</span> <span class="function-name">is_safe</span>(path):
    info = os.stat(path)

    <span class="comment-delimiter"># </span><span class="comment">owner neither superuser nor me 
</span>    <span class="comment-delimiter"># </span><span class="comment">the real uid is in stored in the $&lt; variable
</span>    <span class="keyword">if</span> info.st_uid <span class="keyword">not</span> <span class="keyword">in</span> (0, os.getuid()):
        <span class="keyword">return</span> <span class="py-pseudo-keyword">False</span>

    <span class="comment-delimiter"># </span><span class="comment">check whether group or other can write file.
</span>    <span class="comment-delimiter"># </span><span class="comment">use 066 to detect either reading or writing
</span>    <span class="keyword">if</span> info.st_mode &amp; 022:  <span class="comment-delimiter"># </span><span class="comment">someone else can write this
</span>        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(path):  <span class="comment-delimiter"># </span><span class="comment">non-directories aren't safe
</span>            <span class="keyword">return</span> <span class="py-pseudo-keyword">False</span>
        <span class="comment-delimiter"># </span><span class="comment">but directories with the sticky bit (01000) are
</span>        <span class="keyword">if</span> <span class="keyword">not</span> (info.st_mode &amp; 01000):
            <span class="keyword">return</span> <span class="py-pseudo-keyword">False</span>
    <span class="keyword">return</span> <span class="py-pseudo-keyword">True</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span><span class="comment-delimiter">#</span><span class="comment"># XXX What is '_PC_CHOWN_RESTRICTED'?
</span>
<span class="keyword">def</span> <span class="function-name">is_verysafe</span>(path):
    terms = []
    <span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
        path, ending = os.path.split(path)
        <span class="keyword">if</span> <span class="keyword">not</span> ending:
            <span class="keyword">break</span>
        terms.insert(0, ending)
    <span class="keyword">for</span> term <span class="keyword">in</span> terms:
        path = os.path.join(path, term)
        <span class="keyword">if</span> <span class="keyword">not</span> is_safe(path):
            <span class="keyword">return</span> <span class="py-pseudo-keyword">False</span>
    <span class="keyword">return</span> <span class="py-pseudo-keyword">True</span>
<span class="comment-delimiter">#</span><span class="comment">-----------------------------
</span>
<span class="comment-delimiter"># </span><span class="comment">Program: tctee
</span><span class="comment-delimiter"># </span><span class="comment">Not Implemented (requires reimplementing Perl's builtin '&gt;&gt;', '|',
</span><span class="comment-delimiter"># </span><span class="comment">etc. semantics)
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN484"
>Program: tailwtmp</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">tailwtmp - watch for logins and logouts;
</span><span class="comment-delimiter"># </span><span class="comment">uses linux utmp structure, from /usr/include/bits/utmp.h
</span>
<span class="comment-delimiter"># </span><span class="comment">/* The structure describing an entry in the user accounting database.  */
</span><span class="comment-delimiter"># </span><span class="comment">struct utmp
</span><span class="comment-delimiter"># </span><span class="comment">{
</span><span class="comment-delimiter">#   </span><span class="comment">short int ut_type;            /* Type of login.  */
</span><span class="comment-delimiter">#   </span><span class="comment">pid_t ut_pid;                 /* Process ID of login process.  */
</span><span class="comment-delimiter">#   </span><span class="comment">char ut_line[UT_LINESIZE];    /* Devicename.  */
</span><span class="comment-delimiter">#   </span><span class="comment">char ut_id[4];                /* Inittab ID.  */
</span><span class="comment-delimiter">#   </span><span class="comment">char ut_user[UT_NAMESIZE];    /* Username.  */
</span><span class="comment-delimiter">#   </span><span class="comment">char ut_host[UT_HOSTSIZE];    /* Hostname for remote login.  */
</span><span class="comment-delimiter">#   </span><span class="comment">struct exit_status ut_exit;   /* Exit status of a process marked
</span><span class="comment-delimiter">#                                    </span><span class="comment">as DEAD_PROCESS.  */
</span><span class="comment-delimiter">#   </span><span class="comment">long int ut_session;          /* Session ID, used for windowing.  */
</span><span class="comment-delimiter">#   </span><span class="comment">struct timeval ut_tv;         /* Time entry was made.  */
</span><span class="comment-delimiter">#   </span><span class="comment">int32_t ut_addr_v6[4];        /* Internet address of remote host.  */
</span><span class="comment-delimiter">#   </span><span class="comment">char __unused[20];            /* Reserved for future use.  */
</span><span class="comment-delimiter"># </span><span class="comment">};
</span>
<span class="comment-delimiter"># </span><span class="comment">/* Values for the `ut_type' field of a `struct utmp'.  */
</span><span class="comment-delimiter"># </span><span class="comment">#define EMPTY       0   /* No valid user accounting information.  */
</span><span class="comment-delimiter"># </span><span class="comment">
</span><span class="comment-delimiter"># </span><span class="comment">#define RUN_LVL     1   /* The system's runlevel.  */
</span><span class="comment-delimiter"># </span><span class="comment">#define BOOT_TIME   2   /* Time of system boot.  */
</span><span class="comment-delimiter"># </span><span class="comment">#define NEW_TIME    3   /* Time after system clock changed.  */
</span><span class="comment-delimiter"># </span><span class="comment">#define OLD_TIME    4   /* Time when system clock changed.  */
</span><span class="comment-delimiter"># </span><span class="comment">
</span><span class="comment-delimiter"># </span><span class="comment">#define INIT_PROCESS    5   /* Process spawned by the init process.  */
</span><span class="comment-delimiter"># </span><span class="comment">#define LOGIN_PROCESS   6   /* Session leader of a logged in user.  */
</span><span class="comment-delimiter"># </span><span class="comment">#define USER_PROCESS    7   /* Normal process.  */
</span><span class="comment-delimiter"># </span><span class="comment">#define DEAD_PROCESS    8   /* Terminated process.  */
</span><span class="comment-delimiter"># </span><span class="comment">
</span><span class="comment-delimiter"># </span><span class="comment">#define ACCOUNTING  9
</span>
<span class="keyword">import</span> time
<span class="keyword">import</span> struct
<span class="keyword">import</span> os

<span class="keyword">class</span> <span class="type">WTmpRecord</span>:
    fmt = <span class="string">"hI32s4s32s256siili4l20s"</span>;
    _fieldnames = [<span class="string">"type"</span>,<span class="string">"PID"</span>,<span class="string">"Line"</span>,<span class="string">"inittab"</span>,<span class="string">"User"</span>,<span class="string">"Hostname"</span>,
                    <span class="string">"exit_status"</span>, <span class="string">"session"</span>, <span class="string">"time"</span>, <span class="string">"addr"</span> ]
    <span class="keyword">def</span> <span class="function-name">__init__</span>(<span class="py-pseudo-keyword">self</span>):
        <span class="py-pseudo-keyword">self</span>._rec_size = struct.calcsize(<span class="py-pseudo-keyword">self</span>.fmt)
    <span class="keyword">def</span> <span class="function-name">size</span>(<span class="py-pseudo-keyword">self</span>):
        <span class="keyword">return</span> <span class="py-pseudo-keyword">self</span>._rec_size
    <span class="keyword">def</span> <span class="function-name">unpack</span>(<span class="py-pseudo-keyword">self</span>, bin_data):
        rec = struct.unpack(<span class="py-pseudo-keyword">self</span>.fmt, bin_data)
        <span class="py-pseudo-keyword">self</span>._rec = []
        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="py-builtins">range</span>(len(rec)):
            <span class="keyword">if</span> i <span class="keyword">in</span> (2,3,4,5):
                <span class="comment-delimiter"># </span><span class="comment">remove character zeros from strings
</span>                <span class="py-pseudo-keyword">self</span>._rec.append( rec[i].split(<span class="string">"\0"</span>)[0] )
            <span class="keyword">else:</span>
                <span class="py-pseudo-keyword">self</span>._rec.append(rec[i])
        <span class="keyword">return</span> <span class="py-pseudo-keyword">self</span>._rec
    <span class="keyword">def</span> <span class="function-name">fieldnames</span>(<span class="py-pseudo-keyword">self</span>):
        <span class="keyword">return</span> <span class="py-pseudo-keyword">self</span>._fieldnames
    <span class="keyword">def</span> <span class="function-name">__getattr__</span>(<span class="py-pseudo-keyword">self</span>,name):
        <span class="keyword">return</span> <span class="py-pseudo-keyword">self</span>._rec[<span class="py-pseudo-keyword">self</span>._fieldnames.index(name)]
        
rec = WTmpRecord()
f = <span class="py-builtins">open</span>(<span class="string">"/var/log/wtmp"</span>,<span class="string">"rb"</span>)
f.seek(0,2)
<span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
    <span class="keyword">while</span> <span class="py-pseudo-keyword">True</span>:
        bin = f.read(rec.size())
        <span class="keyword">if</span> <span class="py-builtins">len</span>(bin) != rec.size():
            <span class="keyword">break</span>
        rec.unpack(bin)
        <span class="keyword">if</span> rec.type != 0:
            <span class="keyword">print</span> <span class="string">" %1d %-8s %-12s %-24s %-20s %5d %08x"</span> % \
                (rec.type, rec.User, rec.Line, 
                 time.strftime(<span class="string">"%a %Y-%m-%d %H:%M:%S"</span>,time.localtime(rec.time)),
                 rec.Hostname, rec.PID, rec.addr)
    time.sleep(1)
f.close()</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN487"
>Program: tctee</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter"># </span><span class="comment">@@INCOMPLETE@@
</span><span class="comment-delimiter"># </span><span class="comment">@@INCOMPLETE@@
</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN490"
>Program: laston</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="comment-delimiter"></span><span class="comment"></span><span class="comment-delimiter">#</span><span class="comment">!/usr/bin/python
</span><span class="comment-delimiter"># </span><span class="comment">laston - find out when given user last logged on
</span><span class="keyword">import</span> sys
<span class="keyword">import</span> struct
<span class="keyword">import</span> pwd
<span class="keyword">import</span> time
<span class="keyword">import</span> re

f = <span class="py-builtins">open</span>(<span class="string">"/var/log/lastlog"</span>,<span class="string">"rb"</span>)

fmt = <span class="string">"L32s256s"</span>
rec_size = struct.calcsize(fmt)

<span class="keyword">for</span> user <span class="keyword">in</span> sys.argv[1:]:
    <span class="keyword">if</span> re.match(r<span class="string">"^\d+$"</span>, user):
        user_id = <span class="py-builtins">int</span>(user)
    <span class="keyword">else:</span>
        <span class="keyword">try:</span>
            user_id = pwd.getpwnam(user)[2]
        <span class="keyword">except:</span>
            <span class="keyword">print</span> <span class="string">"no such uid %s"</span> % (user)
            <span class="keyword">continue</span>
    f.seek(rec_size * user_id)
    bin = f.read(rec_size)
    <span class="keyword">if</span> <span class="py-builtins">len</span>(bin) == rec_size:
        data = struct.unpack(fmt, bin)
        <span class="keyword">if</span> data[0]:
            logged_in = <span class="string">"at %s"</span> % (time.strftime(<span class="string">"%a %H:%M:%S %Y-%m-%d"</span>,
                                    time.localtime(data[0])))
            line = <span class="string">" on %s"</span> % (data[1])
            host = <span class="string">" from %s"</span> % (data[2])
        <span class="keyword">else:</span>
            logged_in = <span class="string">"never logged in"</span>
            line = <span class="string">""</span>
            host = <span class="string">""</span>
        <span class="keyword">print</span> <span class="string">"%-8s UID %5d %s%s%s"</span> % (user, user_id, logged_in, line, host)
    <span class="keyword">else:</span>
        <span class="keyword">print</span> <span class="string">"Read failed."</span>
f.close()</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="fileaccess.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="directories.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>File Access</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Directories</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>